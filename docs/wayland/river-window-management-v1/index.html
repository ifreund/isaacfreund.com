<!doctype html><html lang=en><meta name=viewport content="width=device-width,initial-scale=1"><title></title><link rel=icon href=/if.png><link rel=stylesheet href=/style.css><link rel=alternate href=/blog/feed.xml type=application/atom+xml title="Isaac Freund's Blog"><link rel=alternate href=/poetry/feed.xml type=application/atom+xml title="Isaac Freund's Poetry"><link rel=me href=https://hachyderm.io/@ifreund><header><nav><input type=checkbox id=toggle><div class=nav-bar><div class=nav-home><a href=/><svg viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="1" height="1"/><rect x="0" y="2" width="1" height="3"/><path d="M2 0h3v1H3v1h2v1H3v2H2V0z"/><rect x="4" y="4" width="1" height="1"/></svg></a></div><div class=menu><label for=toggle class=menu-button><svg class="menu-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="5" height="1"/><rect x="0" y="2" width="5" height="1"/><rect x="0" y="4" width="5" height="1"/></svg>
<svg class="close-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><line x1="0" y1="0" x2="5" y2="5"/><line x1="0" y1="5" x2="5" y2="0"/></svg></label></div></div></div><div class=nav-items><a href=/about>about</a>
<a href=/blog>blog</a>
<a href=/software>software</a>
<a href=/poetry>poetry</a>
<a href=/consulting>consulting</a></div></nav></header><main class="wayland river-window-management-v1"><div class=title><h1>river-window-management-v1</h1><p class=summary>frame-perfect window management</div><div class=content><div class=description><p>This protocol allows a single "window manager" client to determine the
window management policy of the compositor. State is globally
double-buffered allowing for frame perfect state changes involving multiple
windows.<p>The key words "must", "must not", "required", "shall", "shall not",
"should", "should not", "recommended", "may", and "optional" in this
document are to be interpreted as described in IETF RFC 2119.</div><div class=interface-head><div class=row><div><h2><a id=river_window_manager_v1 href=#river_window_manager_v1>river_window_manager_v1</a></h2><p class=summary>window manager global interface</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>This global interface should only be advertised to the window manager
process. Only one window management client may be active at a time. The
compositor should use the unavailable event if necessary to enforce this.<p>There are two disjoint categories of state managed by this protocol:<p>Window management state influences the communication between the server
and individual window clients (e.g. xdg_toplevels). Window management
state includes window dimensions, fullscreen state, keyboard focus,
keyboard bindings, and more.<p>Rendering state only affects the rendered output of the compositor and
does not influence communication between the server and individual window
clients. Rendering state includes the position and rendering order of
windows, shell surfaces, decoration surfaces, borders, and more.<p>Window management state may only be modified by the window manager as part
of a manage sequence. A manage sequence is started with the manage_start
event and ended with the manage_finish request. It is a protocol error to
modify window management state outside of a manage sequence.<p>A manage sequence is always followed by at least one render sequence. A
render sequence is started with the render_start event and ended with the
render_finish request.<p>Rendering state may be modified by the window manager during a manage
sequence or a render sequence. Regardless of when the rendering state is
modified, it is applied with the next render_finish request. It is a
protocol error to modify rendering state outside of a manage or render
sequence.<p>The server will start a manage sequence by sending new state and the
manage_start event as soon as possible whenever there is a change in state
that must be communicated with the window manager.<p>If the window manager client needs to ensure a manage sequence is started
due to a state change the compositor is not aware of, it may send the
manage_dirty request.<p>The server will start a render sequence by sending new state and the
render_start event as soon as possible whenever there is a change in
window dimensions that must be communicated with the window manager.
Multiple render sequences may be made consecutively without a manage
sequence in between, for example if a window independently changes its own
dimensions.<p>To summarize, the main loop of this protocol is as follows:<p>1. The server sends events indicating all changes since the last
manage sequence followed by the manage_start event.<p>2. The client sends requests modifying window management state or
rendering state (as defined above) followed by the manage_finish
request.<p>3. The server sends new state to windows and waits for responses.<p>4. The server sends new window dimensions to the client followed by the
render_start event.<p>5. The client sends requests modifying rendering state (as defined above)
followed by the render_finish request.<p>6. If window dimensions change, loop back to step 4.
If state that requires a manage sequence changes or if the client makes
a manage_dirty request, loop back to step 1.<p>For the purposes of frame perfection, the server may delay rendering new
state committed by the windows in step 3 until after step 5 is finished.<p>It is a protocol error for the client to make a manage_finish or
render_finish request that violates this ordering.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.stop href=#river_window_manager_v1.stop>river_window_manager_v1.stop</a></h3><p class=summary>stop sending events</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client no longer wishes to receive
events on this object.<p>The Wayland protocol is asynchronous, which means the server may send
further events until the stop request is processed. The client must wait
for a <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.finished>river_window_manager_v1.finished</a></b> event before destroying this
object.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.destroy href=#river_window_manager_v1.destroy>river_window_manager_v1.destroy</a></h3><p class=summary>destroy the river_window_manager_v1 object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request should be called after the finished event has been received
to complete destruction of the object.<p>If a client wishes to destroy this object it should send a
<b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.stop>river_window_manager_v1.stop</a></b> request and wait for a
<b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.finished>river_window_manager_v1.finished</a></b> event. Once the finished event is
received it is safe to destroy this object and any other objects created
through this interface.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.manage_finish href=#river_window_manager_v1.manage_finish>river_window_manager_v1.manage_finish</a></h3><p class=summary>finish a manage sequence</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client has made all changes to window
management state it wishes to include in the current manage sequence and
that the server should atomically send these state changes to the
windows and continue with the manage sequence.<p>After sending this request, it is a protocol error for the client to
make further changes to window management state until the next
manage_start event is received.<p>See the description of the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> interface for a
complete overview of the manage/render sequence loop.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.manage_dirty href=#river_window_manager_v1.manage_dirty>river_window_manager_v1.manage_dirty</a></h3><p class=summary>ensure a manage sequence is started</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request ensures a manage sequence is started and that a
manage_start event is sent by the server. If this request is made during
an ongoing manage sequence, a new manage sequence will be started as
soon as the current one is completed.<p>The client may want to use this request due to an internal state change
that the compositor is not aware of (e.g. a dbus event) which should
affect window management or rendering state.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.render_finish href=#river_window_manager_v1.render_finish>river_window_manager_v1.render_finish</a></h3><p class=summary>finish a render sequence</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client has made all changes to rendering
state it wishes to include in the current manage sequence and that the
server should atomically apply and display these state changes to the
user.<p>After sending this request, it is a protocol error for the client to
make further changes to rendering state until the next manage_start or
render_start event is received, whichever comes first.<p>See the description of the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> interface for a
complete overview of the manage/render sequence loop.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.get_shell_surface href=#river_window_manager_v1.get_shell_surface>river_window_manager_v1.get_shell_surface</a></h3><p class=summary>assign the river_shell_surface_v1 surface role</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a new shell surface for window manager UI and assign the
<b><a href=/docs/wayland/river-window-management-v1/#river_shell_surface_v1>river_shell_surface_v1</a></b> role to the surface.<p>Providing a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> which already has a role or already has a buffer
attached or committed is a protocol error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_shell_surface_v1>river_shell_surface_v1</a></b>><td><p>new river shell surface<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>base surface</table><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.unavailable href=#river_window_manager_v1.unavailable>river_window_manager_v1.unavailable</a></h3><p class=summary>window management unavailable</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that window management is not available to the
client, perhaps due to another window management client already running.
The circumstances causing this event to be sent are compositor policy.<p>If sent, this event is guaranteed to be the first and only event sent by
the server.<p>The server will send no further events on this object. The client should
destroy this object and all objects created through this interface.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.finished href=#river_window_manager_v1.finished>river_window_manager_v1.finished</a></h3><p class=summary>the server has finished with the window manager</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the server will send no further events on this
object. The client should destroy the object. See
<b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.destroy>river_window_manager_v1.destroy</a></b> for more information.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.manage_start href=#river_window_manager_v1.manage_start>river_window_manager_v1.manage_start</a></h3><p class=summary>start a manage sequence</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the server has sent events indicating all
state changes since the last manage sequence.<p>In response to this event, the client should make requests modifying
window management state as it chooses. Then, the client must make the
manage_finish request.<p>See the description of the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> interface for a
complete overview of the manage/render sequence loop.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.render_start href=#river_window_manager_v1.render_start>river_window_manager_v1.render_start</a></h3><p class=summary>start a render sequence</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the server has sent all <b><a href=/docs/wayland/river-window-management-v1/#></a></b>and <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.dimensions>river_window_v1.dimensions</a></b> events necessary.<p>In response to this event, the client should make requests modifying
rendering state as it chooses. Then, the client must make the
render_finish request.<p>See the description of the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> interface for a
complete overview of the manage/render sequence loop.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.session_locked href=#river_window_manager_v1.session_locked>river_window_manager_v1.session_locked</a></h3><p class=summary>the session has been locked</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the session has been locked.<p>The window manager may wish to restrict which key bindings are available
while locked or otherwise use this information.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.session_unlocked href=#river_window_manager_v1.session_unlocked>river_window_manager_v1.session_unlocked</a></h3><p class=summary>the session has been unlocked</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the session has been unlocked.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.window href=#river_window_manager_v1.window>river_window_manager_v1.window</a></h3><p class=summary>new window</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A new window has been created.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b>><td><p>new window</table><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.output href=#river_window_manager_v1.output>river_window_manager_v1.output</a></h3><p class=summary>new output</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A new logical output has been created, perhaps due to a new physical
monitor being plugged in or perhaps due to a change in configuration.<p>This event will be followed by <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1.position>river_output_v1.position</a></b> and dimensions
events as well as a manage_start event after all other new state has
been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b>><td><p>new output</table><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.seat href=#river_window_manager_v1.seat>river_window_manager_v1.seat</a></h3><p class=summary>new seat</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A new seat has been created.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b>><td><p>new seat</table><div class=message-head><div class=row><div><h3><a id=river_window_manager_v1.enums.error href=#river_window_manager_v1.enums.error>river_window_manager_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>sequence_order<td>0<td>1<td><p>request violates manage/render sequence ordering<tr><td>role<td>1<td>1<td><p>given wl_surface already has a role<tr><td>unresponsive<td>2<td>1<td><p>window manager unresponsive</table><div class=interface-head><div class=row><div><h2><a id=river_window_v1 href=#river_window_v1>river_window_v1</a></h2><p class=summary>a logical window</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>This represents a logical window. For example, a window may correspond to
an <b><a href=/docs/wayland/xdg-shell/#xdg_toplevel>xdg_toplevel</a></b> or Xwayland window.<p>A newly created window will not be displayed until the window manager
makes a propose_dimensions or fullscreen request as part of a manage
sequence, the server replies with a dimensions event as part of a render
sequence, and that render sequence is finished.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.destroy href=#river_window_v1.destroy>river_window_v1.destroy</a></h3><p class=summary>destroy the window object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the window
object and that it may be safely destroyed.<p>This request should be made after the <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.closed>river_window_v1.closed</a></b> event or
<b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.finished>river_window_manager_v1.finished</a></b> is received to complete destruction of
the window.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.close href=#river_window_v1.close>river_window_v1.close</a></h3><p class=summary>request that the window be closed</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request that the window be closed. The window may ignore this request or
only close after some delay, perhaps opening a dialog asking the user to
save their work or similar.<p>The server will send a <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.closed>river_window_v1.closed</a></b> event if/when the window
has been closed.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.get_node href=#river_window_v1.get_node>river_window_v1.get_node</a></h3><p class=summary>get the window's render list node</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Get the node in the render list corresponding to the window.<p>It is a protocol error to make this request more than once for a single
window.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_node_v1>river_node_v1</a></b>><td><p>new node</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.propose_dimensions href=#river_window_v1.propose_dimensions>river_window_v1.propose_dimensions</a></h3><p class=summary>propose window dimensions</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request proposes dimensions for the window in the compositor's
logical coordinate space.<p>The width and height must be greater than or equal to zero. If the width
or height is zero the window will be allowed to decide its own
dimensions.<p>The window may not take the exact dimensions proposed. The actual
dimensions taken by the window will be sent in a subsequent
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.dimensions>river_window_v1.dimensions</a></b> event. For example, a terminal emulator may
only allow dimensions that are multiple of the cell size.<p>When a propose_dimensions request is made, the server must send a
dimensions event in response as soon as possible. It may not be possible
to send a dimensions event in the very next render sequence if, for
example, the window takes too long to respond to the proposed
dimensions. In this case, the server will send the dimensions event in a
future render sequence.<p>Note that the dimensions of a <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b> refer to the dimensions of
the window content and are unaffected by the presence of borders or
decoration surfaces.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>width<td>int<td><p>proposed content width<tr><td>height<td>int<td><p>proposed content height</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.hide href=#river_window_v1.hide>river_window_v1.hide</a></h3><p class=summary>request that the window be hidden</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request that the window be hidden. Has no effect if the window is
already hidden. Hides any window borders and decorations as well.<p>Newly created windows are considered shown unless explicitly hidden with
the hide request.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.show href=#river_window_v1.show>river_window_v1.show</a></h3><p class=summary>request that the window be shown</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request that the window be shown. Has no effect if the window is not
hidden. Does not guarantee that the window is visible as it may be
completely obscured by other windows placed above it for example.<p>Newly created windows are considered shown unless explicitly hidden with
the hide request.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.use_csd href=#river_window_v1.use_csd>river_window_v1.use_csd</a></h3><p class=summary>tell the client to use CSD</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Tell the client to use client side decoration and draw its own title
bar, borders, etc.<p>This is the default if neither this request nor the use_ssd request is
ever made.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.use_ssd href=#river_window_v1.use_ssd>river_window_v1.use_ssd</a></h3><p class=summary>tell the client to use SSD</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Tell the client to use server side decoration and not draw any client
side decorations.<p>This request will have no effect if the client only supports client side
decoration, see the decoration_hint event.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.set_borders href=#river_window_v1.set_borders>river_window_v1.set_borders</a></h3><p class=summary>set window borders</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request decorates the window with borders drawn by the compositor
on the specified edges of the window. Borders are drawn above the window
content.<p>Corners are drawn only between borders on adjacent edges. If e.g. the
left edge has a border and the top edge does not, the border drawn on
the left edge will not extend vertically beyond the top edge of the
window.<p>Borders are not drawn while the window is fullscreen.<p>The color is defined by four 32-bit RGBA values. Unless specified in
another protocol extension, the RGBA values use pre-multiplied alpha.<p>Setting the edges to none or the width to 0 disables the borders.
Setting a negative width is a protocol error.<p>This request completely overrides all previous set_borders requests.
Only the most recent set_borders request has an effect.<p>Note that the position/dimensions of a <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b> refer to the
position/dimensions of the window content and are unaffected by the
presence of borders or decoration surfaces.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>edges<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.enums.edges>edges</a></b>><td><p>border edges<tr><td>width<td>int<td><p>border width<tr><td>r<td>uint<td><p>32-bit red value<tr><td>g<td>uint<td><p>32-bit green value<tr><td>b<td>uint<td><p>32-bit blue value<tr><td>a<td>uint<td><p>32-bit alpha value</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.set_tiled href=#river_window_v1.set_tiled>river_window_v1.set_tiled</a></h3><p class=summary>set window tiled state</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is part of a tiled layout and adjacent to
other elements in the tiled layout on the given edges.<p>The window should use this information to change the style of its client
side decorations and avoid drawing e.g. drop shadows outside of the
window dimensions on the tiled edges.<p>Setting the edges argument to none informs the window that it is not
part of a tiled layout. If this request is never made, the window is
informed that it is not part of a tiled layout.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>edges<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.enums.edges>edges</a></b>><td><p>tiled edges</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.get_decoration_above href=#river_window_v1.get_decoration_above>river_window_v1.get_decoration_above</a></h3><p class=summary>create a decoration surface above the window</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a decoration surface and assign the <b><a href=/docs/wayland/river-window-management-v1/#river_decoration_v1>river_decoration_v1</a></b> role to
the surface. The created decoration is placed above the window in
rendering order, see the description of <b><a href=/docs/wayland/river-window-management-v1/#river_decoration_v1>river_decoration_v1</a></b>.<p>Providing a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> which already has a role or already has a buffer
attached or committed is a protocol error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_decoration_v1>river_decoration_v1</a></b>><td><p>new decoration surface<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>base surface</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.get_decoration_below href=#river_window_v1.get_decoration_below>river_window_v1.get_decoration_below</a></h3><p class=summary>create a decoration surface below the window</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a decoration surface and assign the <b><a href=/docs/wayland/river-window-management-v1/#river_decoration_v1>river_decoration_v1</a></b> role to
the surface. The created decoration is placed below the window in
rendering order, see the description of <b><a href=/docs/wayland/river-window-management-v1/#river_decoration_v1>river_decoration_v1</a></b>.<p>Providing a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> which already has a role or already has a buffer
attached or committed is a protocol error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_decoration_v1>river_decoration_v1</a></b>><td><p>new decoration surface<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>base surface</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.inform_resize_start href=#river_window_v1.inform_resize_start>river_window_v1.inform_resize_start</a></h3><p class=summary>inform the window it is being resized</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is being resized. The window manager should
use this request to inform windows that are the target of an interactive
resize for example.<p>The window manager remains responsible for handling the position and
dimensions of the window while it is resizing.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.inform_resize_end href=#river_window_v1.inform_resize_end>river_window_v1.inform_resize_end</a></h3><p class=summary>inform the window it no longer being resized</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is no longer being resized. The window manager
should use this request to inform windows that are the target of an
interactive resize that the interactive resize has ended for example.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.set_capabilities href=#river_window_v1.set_capabilities>river_window_v1.set_capabilities</a></h3><p class=summary>inform window of supported capabilities</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request informs the window of the capabilities supported by the
window manager. If the window manager, for example, ignores requests to
be maximized from the window it should not tell the window that it
supports the maximize capability.<p>The window might use this information to, for example, only show a
maximize button if the window manager supports the maximize capability.<p>The window manager client should use this request to set capabilities
for all new windows. If this request is never made, the compositor will
inform windows that all capabilities are supported.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>caps<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.enums.capabilities>capabilities</a></b>><td><p>supported capabilities</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.inform_maximized href=#river_window_v1.inform_maximized>river_window_v1.inform_maximized</a></h3><p class=summary>inform the window that it is maximized</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is maximized. The window might use this
information to adapt the style of its client-side window decorations for
example.<p>The window manager remains responsible for handling the position and
dimensions of the window while it is maximized.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.inform_unmaximized href=#river_window_v1.inform_unmaximized>river_window_v1.inform_unmaximized</a></h3><p class=summary>inform the window that it is unmaximized</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is unmaximized. The window might use this
information to adapt the style of its client-side window decorations for
example.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.inform_fullscreen href=#river_window_v1.inform_fullscreen>river_window_v1.inform_fullscreen</a></h3><p class=summary>inform the window that it is fullscreen</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is fullscreen. The window might use this
information to adapt the style of its client-side window decorations for
example.<p>This request does not affect the size/position of the window or cause it
to become the only window rendered, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.fullscreen>river_window_v1.fullscreen</a></b>
and exit_fullscreen requests for that.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.inform_not_fullscreen href=#river_window_v1.inform_not_fullscreen>river_window_v1.inform_not_fullscreen</a></h3><p class=summary>inform the window that it is not fullscreen</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Inform the window that it is not fullscreen. The window might use this
information to adapt the style of its client-side window decorations for
example.<p>This request does not affect the size/position of the window or cause it
to become the only window rendered, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.fullscreen>river_window_v1.fullscreen</a></b>
and exit_fullscreen requests for that.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.fullscreen href=#river_window_v1.fullscreen>river_window_v1.fullscreen</a></h3><p class=summary>make the window fullscreen</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Make the window fullscreen on the given output. If multiple windows are
fullscreen on the same output at the same time only the "top" window in
rendering order shall be displayed.<p>All <b><a href=/docs/wayland/river-window-management-v1/#river_shell_surface_v1>river_shell_surface_v1</a></b> objects above the top fullscreen window in
the rendering order will continue to be rendered.<p>The compositor will handle the position and dimensions of the window
while it is fullscreen. The set_position and propose_dimensions requests
shall not affect the current position and dimensions of a fullscreen
window.<p>When a fullscreen request is made, the server must send a dimensions
event in response as soon as possible. It may not be possible to send a
dimensions event in the very next render sequence if, for example, the
window takes too long to respond. In this case, the server will send the
dimensions event in a future render sequence.<p>The compositor will clip window content, decoration surfaces, and
borders to the given output's dimensions while the window is fullscreen.
The effects of set_clip_box and set_content_clip_box are ignored while
the window is fullscreen.<p>If the output on which a window is currently fullscreen is removed, the
windowing state is modified as if there were an exit_fullscreen request
made in the same manage sequence as the <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1.removed>river_output_v1.removed</a></b> event.<p>This request does not inform the window that it is fullscreen, see the
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.inform_fullscreen>river_window_v1.inform_fullscreen</a></b> and inform_not_fullscreen requests.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>output<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b>><td><p>fullscreen output</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.exit_fullscreen href=#river_window_v1.exit_fullscreen>river_window_v1.exit_fullscreen</a></h3><p class=summary>make the window not fullscreen</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Make the window not fullscreen.<p>The position and dimensions are undefined after this request is made
until a manage sequence in which the window manager makes the
propose_dimensions and set_position requests is completed.<p>The window manager should make propose_dimensions and set_position
requests in the same manage sequence as the exit_fullscreen request for
frame perfection.<p>This request does not inform the window that it is fullscreen, see the
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.inform_fullscreen>river_window_v1.inform_fullscreen</a></b> and inform_not_fullscreen requests.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.set_clip_box href=#river_window_v1.set_clip_box>river_window_v1.set_clip_box</a></h3><p class=summary>clip the window to a given box</div><div><b>Request</b><br>Since Version 2</div></div></div><div class=description><p>Clip the window, including borders and decoration surfaces, to the box
specified by the x, y, width, and height arguments. The x/y position of
the box is relative to the top left corner of the window.<p>The width and height arguments must be greater than or equal to 0.<p>Setting a clip box with 0 width or height disables clipping.<p>The clip box is ignored while the window is fullscreen.<p>Both set_clip_box and set_content_clip_box may be enabled simultaneously.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>x relative to top left window corner<tr><td>y<td>int<td><p>y relative to top left window corner<tr><td>width<td>int<td><p>clip box width<tr><td>height<td>int<td><p>clip box height</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.set_content_clip_box href=#river_window_v1.set_content_clip_box>river_window_v1.set_content_clip_box</a></h3><p class=summary>clip the window content to a given box</div><div><b>Request</b><br>Since Version 3</div></div></div><div class=description><p>Clip the content of the window, excluding borders and decoration
surfaces, to the box specified by the x, y, width, and height arguments.
The x/y position of the box is relative to the top left corner of the
window.<p>Borders drawn by the compositor (see set_borders) are placed around the
intersection of the window content (as defined by the dimensions event)
and the content clip box when content clipping is enabled.<p>The width and height arguments must be greater than or equal to 0.<p>Setting a box with 0 width or height disables content clipping.<p>The content clip box is ignored while the window is fullscreen.<p>Both set_clip_box and set_content_clip_box may be enabled simultaneously.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>x relative to top left window corner<tr><td>y<td>int<td><p>y relative to top left window corner<tr><td>width<td>int<td><p>clip box width<tr><td>height<td>int<td><p>clip box height</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.closed href=#river_window_v1.closed>river_window_v1.closed</a></h3><p class=summary>the window has been closed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The window has been closed by the server, perhaps due to an
<b><a href=/docs/wayland/xdg-shell/#xdg_toplevel.close>xdg_toplevel.close</a></b> request or similar.<p>The server will send no further events on this object and ignore any
request other than <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.destroy>river_window_v1.destroy</a></b> made after this event is
sent. The client should destroy this object with the
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.destroy>river_window_v1.destroy</a></b> request to free up resources.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.dimensions_hint href=#river_window_v1.dimensions_hint>river_window_v1.dimensions_hint</a></h3><p class=summary>the window's preferred min/max dimensions</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event informs the window manager of the window's preferred min/max
dimensions. These preferences are a hint, and the window manager is free
to propose dimensions outside of these bounds.<p>All min/max width/height values must be strictly greater than or equal
to 0. A value of 0 indicates that the window has no preference for that
value.<p>The min_width/min_height must be strictly less than or equal to the
max_width/max_height.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>min_width<td>int<td><p>minimum width<tr><td>min_height<td>int<td><p>minimum height<tr><td>max_width<td>int<td><p>maximum width<tr><td>max_height<td>int<td><p>maximum height</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.dimensions href=#river_window_v1.dimensions>river_window_v1.dimensions</a></h3><p class=summary>window dimensions</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates the dimensions of the window in the compositor's
logical coordinate space. The width and height must be strictly greater
than zero.<p>Note that the dimensions of a <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b> refer to the dimensions of
the window content and are unaffected by the presence of borders or
decoration surfaces.<p>This event is sent as part of a render sequence before the render_start
event.<p>It may be sent due to a propose_dimensions or fullscreen request in a
previous manage sequence or because a window independently decides to
change its dimensions.<p>The window will not be displayed until the first dimensions event is
received and the render sequence is finished.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>width<td>int<td><p>window content width<tr><td>height<td>int<td><p>window content height</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.app_id href=#river_window_v1.app_id>river_window_v1.app_id</a></h3><p class=summary>the window set an application ID</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The window set an application ID.<p>The app_id argument will be null if the window has never set an
application ID or if the window cleared its application ID. (Xwayland
windows may do this for example, though xdg-toplevels may not.)<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>app_id<td>nullable
string<td><p>window application ID</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.title href=#river_window_v1.title>river_window_v1.title</a></h3><p class=summary>the window set a title</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The window set a title.<p>The title argument will be null if the window has never set a title or
if the window cleared its title. (Xwayland windows may do this for
example, though xdg-toplevels may not.)<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>title<td>nullable
string<td><p>window title</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.parent href=#river_window_v1.parent>river_window_v1.parent</a></h3><p class=summary>the window set a parent</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The window set a parent window. If this event is never received or if
the parent argument is null then the window has no parent.<p>A surface with a parent set might be a dialog, file picker, or similar
for the parent window.<p>Child windows should generally be rendered directly above their parent.<p>The compositor must guarantee that there are no loops in the window
tree: a parent must not be the descendant of one of its children.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>parent<td>nullable
object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b>><td><p>parent window, if any</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.decoration_hint href=#river_window_v1.decoration_hint>river_window_v1.decoration_hint</a></h3><p class=summary>supported/preferred decoration style</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Information from the window about the supported and preferred client
side/server side decoration options.<p>This event may be sent multiple times over the lifetime of the window if
the window changes its preferences.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>hint<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.enums.decoration_hint>decoration_hint</a></b>><td><p>decoration hint</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.pointer_move_requested href=#river_window_v1.pointer_move_requested>river_window_v1.pointer_move_requested</a></h3><p class=summary>window requested interactive pointer move</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event informs the window manager that the window has requested to
be interactively moved using the pointer. The seat argument indicates the
seat for the move.<p>The xdg-shell protocol for example allows windows to request that an
interactive move be started, perhaps when a client-side rendered
titlebar is dragged.<p>The window manager may use the <b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.op_start_pointer>river_seat_v1.op_start_pointer</a></b> request to
interactively move the window or ignore this event entirely.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b>><td><p>requested seat</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.pointer_resize_requested href=#river_window_v1.pointer_resize_requested>river_window_v1.pointer_resize_requested</a></h3><p class=summary>window requested interactive pointer resize</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event informs the window manager that the window has requested to
be interactively resized using the pointer. The seat argument indicates
the seat for the resize.<p>The edges argument indicates which edges the window has requested to be
resized from. The edges argument will never be none and will never have
both top and bottom or both left and right edges set.<p>The xdg-shell protocol for example allows windows to request that an
interactive resize be started, perhaps when the corner of client-side
rendered decorations is dragged.<p>The window manager may use the <b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.op_start_pointer>river_seat_v1.op_start_pointer</a></b> request to
interactively resize the window or ignore this event entirely.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b>><td><p>requested seat<tr><td>edges<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.enums.edges>edges</a></b>><td><p>requested edges</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.show_window_menu_requested href=#river_window_v1.show_window_menu_requested>river_window_v1.show_window_menu_requested</a></h3><p class=summary>window requested that the window menu be shown</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The xdg-shell protocol for example allows windows to request that a
window menu be shown, for example when the user right clicks on client
side window decorations.<p>A window menu might include options to maximize or minimize the window.<p>The window manager is free to ignore this request and decide what the
window menu contains if it does choose to show one.<p>The x and y arguments indicate where the window requested that the
window menu be shown.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>x offset from top left corner<tr><td>y<td>int<td><p>y offset from top left corner</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.maximize_requested href=#river_window_v1.maximize_requested>river_window_v1.maximize_requested</a></h3><p class=summary>the window requested to be maximized</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The xdg-shell protocol for example allows windows to request to be
maximized.<p>The window manager is free to honor this request using
<b><a href=/docs/wayland/river-window-management-v1/#></a></b>or ignore it.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.unmaximize_requested href=#river_window_v1.unmaximize_requested>river_window_v1.unmaximize_requested</a></h3><p class=summary>the window requested to be unmaximized</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The xdg-shell protocol for example allows windows to request to be
unmaximized.<p>The window manager is free to honor this request using
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.inform_unmaximized>river_window_v1.inform_unmaximized</a></b> or ignore it.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.fullscreen_requested href=#river_window_v1.fullscreen_requested>river_window_v1.fullscreen_requested</a></h3><p class=summary>the window requested to be fullscreen</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The xdg-shell protocol for example allows windows to request that they
be made fullscreen and allows them to provide an output preference.<p>The window manager is free to honor this request using
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.fullscreen>river_window_v1.fullscreen</a></b> or ignore it.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>output<td>nullable
object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b>><td><p>fullscreen output requested</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.exit_fullscreen_requested href=#river_window_v1.exit_fullscreen_requested>river_window_v1.exit_fullscreen_requested</a></h3><p class=summary>the window requested to exit fullscreen</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The xdg-shell protocol for example allows windows to request to exit
fullscreen.<p>The window manager is free to honor this request using
<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.exit_fullscreen>river_window_v1.exit_fullscreen</a></b> or ignore it.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.minimize_requested href=#river_window_v1.minimize_requested>river_window_v1.minimize_requested</a></h3><p class=summary>the window requested to be minimized</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The xdg-shell protocol for example allows windows to request to be
minimized.<p>The window manager is free to ignore this request, hide the window, or
do whatever else it chooses.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_window_v1.unreliable_pid href=#river_window_v1.unreliable_pid>river_window_v1.unreliable_pid</a></h3><p class=summary>unreliable PID of the window's creator</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>This event gives an unreliable PID of the process that created the
window. Obtaining this information is inherently racy due to PID reuse.
Therefore, this PID must not be used for anything security sensitive.<p>Note also that a single process may create multiple windows, so there is
not necessarily a 1-to-1 mapping from PID to window. Multiple windows
may have the same PID.<p>This event is sent once when the <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b> is created and never
sent again.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>unreliable_pid<td>int<td><p>unreliable PID</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.enums.error href=#river_window_v1.enums.error>river_window_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>node_exists<td>0<td>1<td><p>window already has a node object<tr><td>invalid_dimensions<td>1<td>1<td><p>proposed dimensions out of bounds<tr><td>invalid_border<td>2<td>1<td><p>invalid arg to set_borders<tr><td>invalid_clip_box<td>3<td>1<td><p>invalid arg to set_clip_box</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.enums.decoration_hint href=#river_window_v1.enums.decoration_hint>river_window_v1.decoration_hint</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>only_supports_csd<td>0<td>1<td><p>only supports client side decoration<tr><td>prefers_csd<td>1<td>1<td><p>client side decoration preferred, both CSD and SSD supported<tr><td>prefers_ssd<td>2<td>1<td><p>server side decoration preferred, both CSD and SSD supported<tr><td>no_preference<td>3<td>1<td><p>no preference, both CSD and SSD supported</table><div class=message-head><div class=row><div><h3><a id=river_window_v1.enums.edges href=#river_window_v1.enums.edges>river_window_v1.edges</a></h3><p class=summary></div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>none<td>0<td>1<td><p><tr><td>top<td>1<td>1<td><p><tr><td>bottom<td>2<td>1<td><p><tr><td>left<td>4<td>1<td><p><tr><td>right<td>8<td>1<td><p></table><div class=message-head><div class=row><div><h3><a id=river_window_v1.enums.capabilities href=#river_window_v1.enums.capabilities>river_window_v1.capabilities</a></h3><p class=summary></div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>window_menu<td>1<td>1<td><p><tr><td>maximize<td>2<td>1<td><p><tr><td>fullscreen<td>4<td>1<td><p><tr><td>minimize<td>8<td>1<td><p></table><div class=interface-head><div class=row><div><h2><a id=river_decoration_v1 href=#river_decoration_v1>river_decoration_v1</a></h2><p class=summary>a window decoration</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>The rendering order of windows with decorations is follows:<p>1. Decorations created with get_decoration_below at the bottom
2. Window content
3. Borders configured with <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.set_borders>river_window_v1.set_borders</a></b>
4. Decorations created with get_decoration_above at the top<p>The relative ordering of decoration surfaces above/below a window is
undefined by this protocol and left up to the compositor.</div><div class=message-head><div class=row><div><h3><a id=river_decoration_v1.destroy href=#river_decoration_v1.destroy>river_decoration_v1.destroy</a></h3><p class=summary>destroy the decoration object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the decoration
object and that it may be safely destroyed.</div><div class=message-head><div class=row><div><h3><a id=river_decoration_v1.set_offset href=#river_decoration_v1.set_offset>river_decoration_v1.set_offset</a></h3><p class=summary>set offset from the window's top left corner</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request sets the offset of the decoration surface from the top left
corner of the window.<p>If this request is never sent, the x and y offsets are undefined by this
protocol and left up to the compositor.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>x relative to top left window corner<tr><td>y<td>int<td><p>y relative to top left window corner</table><div class=message-head><div class=row><div><h3><a id=river_decoration_v1.sync_next_commit href=#river_decoration_v1.sync_next_commit>river_decoration_v1.sync_next_commit</a></h3><p class=summary>sync next commit with other rendering state</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Synchronize application of the next <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> request on the
decoration surface with rest of the state atomically applied with the
next <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.render_finish>river_window_manager_v1.render_finish</a></b> request.<p>The client must make a <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> request on the decoration
surface after this request and before the render_finish request, failure
to do so is a protocol error.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_decoration_v1.enums.error href=#river_decoration_v1.enums.error>river_decoration_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>no_commit<td>0<td>1<td><p>failed to commit the surface before the window manager commit</table><div class=interface-head><div class=row><div><h2><a id=river_shell_surface_v1 href=#river_shell_surface_v1>river_shell_surface_v1</a></h2><p class=summary>a surface for window manager UI</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>The window manager might use a shell surface to display a status bar,
background image, desktop notifications, launcher, desktop menu, or
whatever else it wants.</div><div class=message-head><div class=row><div><h3><a id=river_shell_surface_v1.destroy href=#river_shell_surface_v1.destroy>river_shell_surface_v1.destroy</a></h3><p class=summary>destroy the shell surface object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the shell
surface object and that it may be safely destroyed.</div><div class=message-head><div class=row><div><h3><a id=river_shell_surface_v1.get_node href=#river_shell_surface_v1.get_node>river_shell_surface_v1.get_node</a></h3><p class=summary>get the shell surface's render list node</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Get the node in the render list corresponding to the shell surface.<p>It is a protocol error to make this request more than once for a single
shell surface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_node_v1>river_node_v1</a></b>><td><p>new node</table><div class=message-head><div class=row><div><h3><a id=river_shell_surface_v1.sync_next_commit href=#river_shell_surface_v1.sync_next_commit>river_shell_surface_v1.sync_next_commit</a></h3><p class=summary>sync next surface commit to window manager commit</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Synchronize application of the next <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> request on the
shell surface with rest of the rendering state atomically applied with
the next <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.render_finish>river_window_manager_v1.render_finish</a></b> request.<p>The client must make a <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> request on the shell surface
after this request and before the render_finish request, failure to do
so is a protocol error.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_shell_surface_v1.enums.error href=#river_shell_surface_v1.enums.error>river_shell_surface_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>node_exists<td>0<td>1<td><p>shell surface already has a node object<tr><td>no_commit<td>1<td>1<td><p>failed to commit the surface before the window manager commit</table><div class=interface-head><div class=row><div><h2><a id=river_node_v1 href=#river_node_v1>river_node_v1</a></h2><p class=summary>a node in the render list</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>The render list is a list of nodes that determines the rendering order of
the compositor. Nodes may correspond to windows or shell surfaces. The
relative ordering of nodes may be changed with the place_above and
place_below requests, changing the rendering order.<p>The initial position of a node in the render list is undefined, the window
manager client must use the place_above or place_below request to
guarantee a specific rendering order.</div><div class=message-head><div class=row><div><h3><a id=river_node_v1.destroy href=#river_node_v1.destroy>river_node_v1.destroy</a></h3><p class=summary>destroy the decoration object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the node
object and that it may be safely destroyed.</div><div class=message-head><div class=row><div><h3><a id=river_node_v1.set_position href=#river_node_v1.set_position>river_node_v1.set_position</a></h3><p class=summary>set absolute position of the node</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Set the absolute position of the node in the compositor's logical
coordinate space. The x and y coordinates may be positive or negative.<p>Note that the position of a <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b> refers to the position of
the window content and is unaffected by the presence of borders or
decoration surfaces.<p>If this request is never sent, the position of the node is undefined by
this protocol and left up to the compositor.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>global x coordinate<tr><td>y<td>int<td><p>global y coordinate</table><div class=message-head><div class=row><div><h3><a id=river_node_v1.place_top href=#river_node_v1.place_top>river_node_v1.place_top</a></h3><p class=summary>place node above all other nodes</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request places the node above all other nodes in the compositor's
render list.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_node_v1.place_bottom href=#river_node_v1.place_bottom>river_node_v1.place_bottom</a></h3><p class=summary>place node below all other nodes</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request places the node below all other nodes in the compositor's
render list.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_node_v1.place_above href=#river_node_v1.place_above>river_node_v1.place_above</a></h3><p class=summary>place node above another node</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request places the node directly above another node in the
compositor's render list.<p>Attempting to place a node above itself has no effect.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>other<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_node_v1>river_node_v1</a></b>><td><p>other node</table><div class=message-head><div class=row><div><h3><a id=river_node_v1.place_below href=#river_node_v1.place_below>river_node_v1.place_below</a></h3><p class=summary>place node below another node</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request places the node directly below another node in the
compositor's render list.<p>Attempting to place a node below itself has no effect.<p>This request modifies rendering state and may only be made as part of a
render sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>other<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_node_v1>river_node_v1</a></b>><td><p>other node</table><div class=interface-head><div class=row><div><h2><a id=river_output_v1 href=#river_output_v1>river_output_v1</a></h2><p class=summary>a logical output</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>An area in the compositor's logical coordinate space that should be
treated as a single output for window management purposes. This area may
correspond to a single physical output or multiple physical outputs in the
case of mirroring or tiled monitors depending on the hardware and
compositor configuration.</div><div class=message-head><div class=row><div><h3><a id=river_output_v1.destroy href=#river_output_v1.destroy>river_output_v1.destroy</a></h3><p class=summary>destroy the output object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the output
object and that it may be safely destroyed.<p>This request should be made after the <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1.removed>river_output_v1.removed</a></b> event is
received to complete destruction of the output.</div><div class=message-head><div class=row><div><h3><a id=river_output_v1.removed href=#river_output_v1.removed>river_output_v1.removed</a></h3><p class=summary>the output is removed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the logical output is no longer conceptually
part of window management space.<p>The server will send no further events on this object and ignore any
request (other than <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1.destroy>river_output_v1.destroy</a></b>) made after this event is
sent. The client should destroy this object with the
<b><a href=/docs/wayland/river-window-management-v1/#river_output_v1.destroy>river_output_v1.destroy</a></b> request to free up resources.<p>This event may be sent because a corresponding physical output has been
physically unplugged or because some output configuration has changed.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_output_v1.wl_output href=#river_output_v1.wl_output>river_output_v1.wl_output</a></h3><p class=summary>corresponding wl_output</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> object corresponding to the <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b>. The argument
is the global name of the <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> advertised with <b><a href=/docs/wayland/wayland/#wl_registry.global>wl_registry.global</a></b>.<p>It is guaranteed that the corresponding <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> is advertised before
this event is sent.<p>This event is sent exactly once. The <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> associated with a
<b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b> cannot change. It is guaranteed that there is a 1-to-1
mapping between <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> and <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b> objects.<p>The global_remove event for the corresponding <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> may be sent
before the <b><a href=/docs/wayland/river-window-management-v1/#></a></b>event. This is due to the fact that
<b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b> state changes are synced to the river window management
manage sequence while changes to globals are not.<p>Rationale: The window manager may need information provided by the
<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> interface such as the name/description. It also may need the
<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> object to start screencopy for example.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>uint<td><p>name of the wl_output global</table><div class=message-head><div class=row><div><h3><a id=river_output_v1.position href=#river_output_v1.position>river_output_v1.position</a></h3><p class=summary>output position</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates the position of the output in the compositor's
logical coordinate space. The x and y coordinates may be positive or
negative.<p>This event is sent once when the <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b> is created and again
whenever the position changes.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.<p>The server must guarantee that the position and dimensions events do not
cause the areas of multiple logical outputs to overlap when the
corresponding manage_start event is received.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>global x coordinate<tr><td>y<td>int<td><p>global y coordinate</table><div class=message-head><div class=row><div><h3><a id=river_output_v1.dimensions href=#river_output_v1.dimensions>river_output_v1.dimensions</a></h3><p class=summary>output dimensions</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates the dimensions of the output in the compositor's
logical coordinate space. The width and height will always be strictly
greater than zero.<p>This event is sent once when the <b><a href=/docs/wayland/river-window-management-v1/#river_output_v1>river_output_v1</a></b> is created and again
whenever the dimensions change.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.<p>The server must guarantee that the position and dimensions events do not
cause the areas of multiple logical outputs to overlap when the
corresponding manage_start event is received.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>width<td>int<td><p>output width<tr><td>height<td>int<td><p>output height</table><div class=interface-head><div class=row><div><h2><a id=river_seat_v1 href=#river_seat_v1>river_seat_v1</a></h2><p class=summary>a window management seat</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>This object represents a single user's collection of input devices. It
allows the window manager to route keyboard input to windows, get
high-level information about pointer input, define keyboard and pointer
bindings, etc.<p>TODO:
- touch input
- tablet input</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.destroy href=#river_seat_v1.destroy>river_seat_v1.destroy</a></h3><p class=summary>destroy the seat object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the seat
object and that it may be safely destroyed.<p>This request should be made after the <b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.removed>river_seat_v1.removed</a></b> event is
received to complete destruction of the seat.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.focus_window href=#river_seat_v1.focus_window>river_seat_v1.focus_window</a></h3><p class=summary>give keyboard focus to a window</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request that the compositor send keyboard input to the given window.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>window<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b>><td><p>window to focus</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.focus_shell_surface href=#river_seat_v1.focus_shell_surface>river_seat_v1.focus_shell_surface</a></h3><p class=summary>give keyboard focus to a shell_surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request that the compositor send keyboard input to the given shell
surface.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>shell_surface<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_shell_surface_v1>river_shell_surface_v1</a></b>><td><p>shell surface to focus</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.clear_focus href=#river_seat_v1.clear_focus>river_seat_v1.clear_focus</a></h3><p class=summary>clear keyboard focus</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request that the compositor not send keyboard input to any client.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.op_start_pointer href=#river_seat_v1.op_start_pointer>river_seat_v1.op_start_pointer</a></h3><p class=summary>start an interactive pointer operation</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Start an interactive pointer operation. During the operation, op_delta
events will be sent based on pointer input.<p>When all pointer buttons are released, the op_release event is sent.<p>The pointer operation continues until the op_end request is made during
a manage sequence and that manage sequence is finished.<p>The window manager may use this operation to implement interactive
move/resize of windows by setting the position of windows and proposing
dimensions based off of the op_delta events.<p>This request is ignored if an operation is already in progress.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.op_end href=#river_seat_v1.op_end>river_seat_v1.op_end</a></h3><p class=summary>end an interactive operation</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>End an interactive operation.<p>This request is ignored if there is no operation in progress.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.get_pointer_binding href=#river_seat_v1.get_pointer_binding>river_seat_v1.get_pointer_binding</a></h3><p class=summary>define a new pointer binding</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Define a pointer binding in terms of a pointer button, keyboard
modifiers, and other configurable properties.<p>The button argument is a Linux input event code defined in the
linux/input-event-codes.h header file (e.g. BTN_RIGHT).<p>The new pointer binding is not enabled until initial configuration is
completed and the enable request is made during a manage sequence.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_pointer_binding_v1>river_pointer_binding_v1</a></b>><td><p>new pointer binding<tr><td>button<td>uint<td><p>a Linux input event code<tr><td>modifiers<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.enums.modifiers>modifiers</a></b>><td><p>keyboard modifiers</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.set_xcursor_theme href=#river_seat_v1.set_xcursor_theme>river_seat_v1.set_xcursor_theme</a></h3><p class=summary>set the xcursor theme for the seat</div><div><b>Request</b><br>Since Version 2</div></div></div><div class=description><p>Set the XCursor theme for the seat. This theme is used for cursors
rendered by the compositor, but not necessarily for cursors rendered by
clients.<p>Note: The window manager may also wish to set the XCURSOR_THEME and
XCURSOR_SIZE environment variable for programs it starts.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>string<td><p>xcursor theme name<tr><td>size<td>uint<td><p>cursor size</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.pointer_warp href=#river_seat_v1.pointer_warp>river_seat_v1.pointer_warp</a></h3><p class=summary>warp the pointer to a given position</div><div><b>Request</b><br>Since Version 3</div></div></div><div class=description><p>Warp the pointer to the given position in the compositor's logical
coordinate space.<p>If the given position is outside the bounds of all outputs, the pointer
will be warped to the closest point inside an output instead.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>global x coordinate<tr><td>y<td>int<td><p>global y coordinate</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.removed href=#river_seat_v1.removed>river_seat_v1.removed</a></h3><p class=summary>the seat is removed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that seat is no longer in use and should be
destroyed.<p>The server will send no further events on this object and ignore any
request (other than <b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.destroy>river_seat_v1.destroy</a></b>) made after this event is
sent. The client should destroy this object with the
<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.destroy>river_seat_v1.destroy</a></b> request to free up resources.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.wl_seat href=#river_seat_v1.wl_seat>river_seat_v1.wl_seat</a></h3><p class=summary>corresponding wl_seat</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> object corresponding to the <b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b>. The argument is
the global name of the <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> advertised with <b><a href=/docs/wayland/wayland/#wl_registry.global>wl_registry.global</a></b>.<p>It is guaranteed that the corresponding <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> is advertised before
this event is sent.<p>This event is sent exactly once. The <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> associated with a
<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b> cannot change. It is guaranteed that there is a 1-to-1
mapping between <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> and <b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b> objects.<p>The global_remove event for the corresponding <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> may be sent before
the <b><a href=/docs/wayland/river-window-management-v1/#></a></b>event. This is due to the fact that
<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b> state changes are synced to the river window management
manage sequence while changes to globals are not.<p>Rationale: The window manager may want to trigger window management
state changes based on normal input events received by its shell
surfaces for example.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>uint<td><p>name of the wl_seat global</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.pointer_enter href=#river_seat_v1.pointer_enter>river_seat_v1.pointer_enter</a></h3><p class=summary>pointer entered a window</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The seat's pointer entered the given window's area.<p>The area of a window is defined to include the area defined by the
window dimensions, borders configured using <b><a href=/docs/wayland/river-window-management-v1/#river_window_v1.set_borders>river_window_v1.set_borders</a></b>,
and the input regions of decoration surfaces. In particular, it does not
include input regions of surfaces belonging to the window that extend
outside the window dimensions.<p>The pointer of a seat may only enter a single window at a time. When the
pointer moves between windows, the pointer_leave event for the old
window must be sent before the pointer_enter event for the new window.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>window<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b>><td><p>window entered</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.pointer_leave href=#river_seat_v1.pointer_leave>river_seat_v1.pointer_leave</a></h3><p class=summary>pointer left the entered window</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The seat's pointer left the window for which pointer_enter was most
recently sent. See pointer_enter for details.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.window_interaction href=#river_seat_v1.window_interaction>river_seat_v1.window_interaction</a></h3><p class=summary>a window has been interacted with</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A window has been interacted with beyond the pointer merely passing over
it. This event might be sent due to a pointer button press or due to a
touch/tablet tool interaction with the window.<p>There are no guarantees regarding how this event is sent in relation to
the pointer_enter and pointer_leave events as the interaction may use
touch or tablet tool input.<p>Rationale: this event gives window managers necessary information to
determine when to send keyboard focus, raise a window that already has
keyboard focus, etc. Rather than expose all pointer, touch, and tablet
events to window managers, a policy over mechanism approach is taken.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>window<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_window_v1>river_window_v1</a></b>><td><p>window interacted with</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.shell_surface_interaction href=#river_seat_v1.shell_surface_interaction>river_seat_v1.shell_surface_interaction</a></h3><p class=summary>a shell surface has been interacted with</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A shell surface has been interacted with beyond the pointer merely
passing over it. This event might be sent due to a pointer button press
or due to a touch/tablet tool interaction with the shell_surface.<p>There are no guarantees regarding how this event is sent in relation to
the pointer_enter and pointer_leave events as the interaction may use
touch or tablet tool input.<p>Rationale: While the shell surface does receive all <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b>,
<b><a href=/docs/wayland/wayland/#wl_touch>wl_touch</a></b>, etc. input events for the surface directly, these events do
not necessarily trigger a manage sequence and therefore do not allow the
window manager to update focus or perform other actions in response to
the input in a race-free way.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>shell_surface<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_shell_surface_v1>river_shell_surface_v1</a></b>><td><p>shell surface interacted with</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.op_delta href=#river_seat_v1.op_delta>river_seat_v1.op_delta</a></h3><p class=summary>total cumulative motion since op start</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates the total change in position since the start of the
operation of the pointer/touch point/etc.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>dx<td>int<td><p>total change in x<tr><td>dy<td>int<td><p>total change in y</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.op_release href=#river_seat_v1.op_release>river_seat_v1.op_release</a></h3><p class=summary>operation input has been released</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The input driving the current interactive operation has been released.
For a pointer op for example, all pointer buttons have been released.<p>Depending on the op type, op_delta events may continue to be sent until
the op is ended with the op_end request.<p>This event is sent at most once during an interactive operation.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=message-head><div class=row><div><h3><a id=river_seat_v1.pointer_position href=#river_seat_v1.pointer_position>river_seat_v1.pointer_position</a></h3><p class=summary>The current position of the pointer</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>The current position of the pointer in the compositor's logical
coordinate space.<p>This state is special in that a change in pointer position alone must
not cause the compositor to start a manage sequence.<p>Assuming the seat has a pointer, this event must be sent in every manage
sequence unless there is no change in x/y position since the last time this
event was sent.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>global x coordinate<tr><td>y<td>int<td><p>global y coordinate</table><div class=message-head><div class=row><div><h3><a id=river_seat_v1.enums.modifiers href=#river_seat_v1.enums.modifiers>river_seat_v1.modifiers</a></h3><p class=summary>a set of keyboard modifiers</div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><div class=description><p>This enum is used to describe the keyboard modifiers that must be held
down to trigger a key binding or pointer binding.<p>Note that river and wlroots use the values 2 and 16 for capslock and
numlock internally. It doesn't make sense to use locked modifiers for
bindings however so these values are not included in this enum.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>none<td>0<td>1<td><p><tr><td>shift<td>1<td>1<td><p><tr><td>ctrl<td>4<td>1<td><p><tr><td>mod1<td>8<td>1<td><p>commonly called alt<tr><td>mod3<td>32<td>1<td><p><tr><td>mod4<td>64<td>1<td><p>commonly called super or logo<tr><td>mod5<td>128<td>1<td><p></table><div class=interface-head><div class=row><div><h2><a id=river_pointer_binding_v1 href=#river_pointer_binding_v1>river_pointer_binding_v1</a></h2><p class=summary>configure a pointer binding, receive trigger events</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>This object allows the window manager to configure a pointer binding and
receive events when the binding is triggered.<p>The new pointer binding is not enabled until the enable request is made
during a manage sequence.<p>Normally, all pointer button events are sent to the surface with pointer
focus by the compositor. Pointer button events that trigger a pointer
binding are not sent to the surface with pointer focus.<p>If multiple pointer bindings would be triggered by a single physical
pointer event on the compositor side, it is compositor policy which
pointer binding(s) will receive press/release events or if all of the
matched pointer bindings receive press/release events.</div><div class=message-head><div class=row><div><h3><a id=river_pointer_binding_v1.destroy href=#river_pointer_binding_v1.destroy>river_pointer_binding_v1.destroy</a></h3><p class=summary>destroy the pointer binding object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the pointer
binding object and that it may be safely destroyed.</div><div class=message-head><div class=row><div><h3><a id=river_pointer_binding_v1.enable href=#river_pointer_binding_v1.enable>river_pointer_binding_v1.enable</a></h3><p class=summary>enable the pointer binding</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request should be made after all initial configuration has been
completed and the window manager wishes the pointer binding to be able
to be triggered.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_pointer_binding_v1.disable href=#river_pointer_binding_v1.disable>river_pointer_binding_v1.disable</a></h3><p class=summary>disable the pointer binding</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request may be used to temporarily disable the pointer binding. It
may be later re-enabled with the enable request.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_pointer_binding_v1.pressed href=#river_pointer_binding_v1.pressed>river_pointer_binding_v1.pressed</a></h3><p class=summary>the bound pointer button has been pressed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the pointer button triggering the binding has
been pressed.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.<p>The compositor should wait for the manage sequence to complete before
processing further input events. This allows the window manager client
to, for example, modify key bindings and keyboard focus without racing
against future input events. The window manager should of course respond
as soon as possible as the capacity of the compositor to buffer incoming
input events is finite.</div><div class=message-head><div class=row><div><h3><a id=river_pointer_binding_v1.released href=#river_pointer_binding_v1.released>river_pointer_binding_v1.released</a></h3><p class=summary>the bound pointer button has been released</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the pointer button triggering the binding has
been released.<p>Releasing the modifiers for the binding without releasing the pointer
button does not trigger the release event. This event is sent when the
pointer button is released, even if the modifiers have changed since the
pressed event.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.<p>The compositor should wait for the manage sequence to complete before
processing further input events. This allows the window manager client
to, for example, modify key bindings and keyboard focus without racing
against future input events. The window manager should of course respond
as soon as possible as the capacity of the compositor to buffer incoming
input events is finite.</div><div class=interface-head><h2>Copyright</h2></div><div class=copyright><p><br>SPDX-FileCopyrightText:  2024 Isaac Freund<br>SPDX-License-Identifier: MIT<br><br>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the "Software"), to<br>deal in the Software without restriction, including without limitation the<br>rights to use, copy, modify, merge, publish, distribute, sublicense, and/or<br>sell copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:<br><br>The above copyright notice and this permission notice shall be included in<br>all copies or substantial portions of the Software.<br><br>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br>FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br>IN THE SOFTWARE.<br></div></div></main><footer><span class=line> 2021-2026 Isaac Freund,</span>
<span class=line><a href=/impressum>Impressum</a>,</span>
<span class=line>Content <a href=/CC-BY-NC-SA-4.0.txt>CC-BY-NC-SA-4.0</a>,</span>
<span class=line><a href=https://codeberg.org/ifreund/website>Source Code</a> <a href=/AGPL-3.0-only.txt>AGPL-3.0-only</a></span></footer>