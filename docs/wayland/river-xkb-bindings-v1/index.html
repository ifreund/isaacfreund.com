<!doctype html><html lang=en><meta name=viewport content="width=device-width,initial-scale=1"><title></title><link rel=icon href=/if.png><link rel=stylesheet href=/style.css><link rel=alternate href=/blog/feed.xml type=application/atom+xml title="Isaac Freund's Blog"><link rel=alternate href=/poetry/feed.xml type=application/atom+xml title="Isaac Freund's Poetry"><link rel=me href=https://hachyderm.io/@ifreund><header><nav><input type=checkbox id=toggle><div class=nav-bar><div class=nav-home><a href=/><svg viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="1" height="1"/><rect x="0" y="2" width="1" height="3"/><path d="M2 0h3v1H3v1h2v1H3v2H2V0z"/><rect x="4" y="4" width="1" height="1"/></svg></a></div><div class=menu><label for=toggle class=menu-button><svg class="menu-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="5" height="1"/><rect x="0" y="2" width="5" height="1"/><rect x="0" y="4" width="5" height="1"/></svg>
<svg class="close-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><line x1="0" y1="0" x2="5" y2="5"/><line x1="0" y1="5" x2="5" y2="0"/></svg></label></div></div></div><div class=nav-items><a href=/about>about</a>
<a href=/blog>blog</a>
<a href=/software>software</a>
<a href=/poetry>poetry</a>
<a href=/consulting>consulting</a></div></nav></header><main class="wayland-protocol river-xkb-bindings-v1"><div class=title><div class=row><div><h1>river-xkb-bindings-v1</h1><p class=summary>xkbcommon-based key bindings</div><div><p>(<a href=/docs/wayland>back</a>)<p></div></div></div><div class=content><div class=description><p>This protocol allows the river-window-management-v1 window manager to
define key bindings in terms of xkbcommon keysyms and other configurable
properties.<p>The key words "must", "must not", "required", "shall", "shall not",
"should", "should not", "recommended", "may", and "optional" in this
document are to be interpreted as described in IETF RFC 2119.</div><div class=interface-head><div class=row><div><h2><a id=river_xkb_bindings_v1 href=#river_xkb_bindings_v1>river_xkb_bindings_v1</a></h2><p class=summary>xkbcommon bindings global interface</div><div><b>Interface</b><br>Version 2</div></div></div><div class=description><p>This global interface should only be advertised to the client if the
<b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> global is also advertised.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_v1.destroy href=#river_xkb_bindings_v1.destroy>river_xkb_bindings_v1.destroy</a></h3><p class=summary>destroy the river_xkb_bindings_v1 object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the
<b><a href=/docs/wayland/river-xkb-bindings-v1/#river_xkb_bindings_v1>river_xkb_bindings_v1</a></b> object.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_v1.get_xkb_binding href=#river_xkb_bindings_v1.get_xkb_binding>river_xkb_bindings_v1.get_xkb_binding</a></h3><p class=summary>define a new xkbcommon key binding</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Define a key binding for the given seat in terms of an xkbcommon keysym
and other configurable properties.<p>The new key binding is not enabled until initial configuration is
completed and the enable request is made during a manage sequence.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b>><td><p><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-xkb-bindings-v1/#river_xkb_binding_v1>river_xkb_binding_v1</a></b>><td><p><tr><td>keysym<td>uint<td><p>an xkbcommon keysym<tr><td>modifiers<td>uint&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1.enums.modifiers>river_seat_v1.modifiers</a></b>><td><p></table><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_v1.get_seat href=#river_xkb_bindings_v1.get_seat>river_xkb_bindings_v1.get_seat</a></h3><p class=summary>manage seat-specific state</div><div><b>Request</b><br>Since Version 2</div></div></div><div class=description><p>Create an object to manage seat-specific xkb bindings state.<p>It is a protocol error to make this request more than once for a given
<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b> object.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/river-xkb-bindings-v1/#river_xkb_bindings_seat_v1>river_xkb_bindings_seat_v1</a></b>><td><p><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/river-window-management-v1/#river_seat_v1>river_seat_v1</a></b>><td><p></table><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_v1.enums.error href=#river_xkb_bindings_v1.enums.error>river_xkb_bindings_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 2</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>object_already_created<td>0<td>2<td><p></table><div class=interface-head><div class=row><div><h2><a id=river_xkb_binding_v1 href=#river_xkb_binding_v1>river_xkb_binding_v1</a></h2><p class=summary>configure a xkb key binding, receive trigger events</div><div><b>Interface</b><br>Version 2</div></div></div><div class=description><p>This object allows the window manager to configure a xkbcommon key binding
and receive events when the key binding is triggered.<p>The new key binding is not enabled until the enable request is made during
a manage sequence.<p>Normally, all key events are sent to the surface with keyboard focus by
the compositor. Key events that trigger a key binding are not sent to the
surface with keyboard focus.<p>If multiple key bindings would be triggered by a single physical key event
on the compositor side, it is compositor policy which key binding(s) will
receive press/release events or if all of the matched key bindings receive
press/release events.<p>Key bindings might be matched by the same physical key event due to shared
keysym and modifiers. The layout override feature may also cause the same
physical key event to trigger two key bindings with different keysyms and
different layout overrides configured.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.destroy href=#river_xkb_binding_v1.destroy>river_xkb_binding_v1.destroy</a></h3><p class=summary>destroy the xkb binding object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the client will no longer use the xkb key
binding object and that it may be safely destroyed.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.set_layout_override href=#river_xkb_binding_v1.set_layout_override>river_xkb_binding_v1.set_layout_override</a></h3><p class=summary>override currently active xkb layout</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Specify an xkb layout that should be used to translate key events for
the purpose of triggering this key binding irrespective of the currently
active xkb layout.<p>The layout argument is a 0-indexed xkbcommon layout number for the
keyboard that generated the key event.<p>If this request is never made, the currently active xkb layout of the
keyboard that generated the key event will be used.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>layout<td>uint<td><p>0-indexed xkbcommon layout</table><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.enable href=#river_xkb_binding_v1.enable>river_xkb_binding_v1.enable</a></h3><p class=summary>enable the key binding</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request should be made after all initial configuration has been
completed and the window manager wishes the key binding to be able to be
triggered.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.disable href=#river_xkb_binding_v1.disable>river_xkb_binding_v1.disable</a></h3><p class=summary>disable the key binding</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request may be used to temporarily disable the key binding. It may
be later re-enabled with the enable request.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.pressed href=#river_xkb_binding_v1.pressed>river_xkb_binding_v1.pressed</a></h3><p class=summary>the key triggering the binding has been pressed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the physical key triggering the binding has
been pressed.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.<p>The compositor should wait for the manage sequence to complete before
processing further input events. This allows the window manager client
to, for example, modify key bindings and keyboard focus without racing
against future input events. The window manager should of course respond
as soon as possible as the capacity of the compositor to buffer incoming
input events is finite.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.released href=#river_xkb_binding_v1.released>river_xkb_binding_v1.released</a></h3><p class=summary>the key triggering the binding has been released</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event indicates that the physical key triggering the binding has
been released.<p>Releasing the modifiers for the binding without releasing the "main"
physical key that produces the bound keysym does not trigger the release
event. This event is sent when the "main" key is released, even if the
modifiers have changed since the pressed event.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.<p>The compositor should wait for the manage sequence to complete before
processing further input events. This allows the window manager client
to, for example, modify key bindings and keyboard focus without racing
against future input events. The window manager should of course respond
as soon as possible as the capacity of the compositor to buffer incoming
input events is finite.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_binding_v1.stop_repeat href=#river_xkb_binding_v1.stop_repeat>river_xkb_binding_v1.stop_repeat</a></h3><p class=summary>repeating should be stopped</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>This event indicates that repeating should be stopped for the binding if
the window manager has been repeating some action since the pressed
event.<p>This event is generally sent when some other (possible unbound) key is
pressed after the pressed event is sent and before the released event
is sent for this binding.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=interface-head><div class=row><div><h2><a id=river_xkb_bindings_seat_v1 href=#river_xkb_bindings_seat_v1>river_xkb_bindings_seat_v1</a></h2><p class=summary>xkb bindings seat</div><div><b>Interface</b><br>Version 2</div></div></div><div class=description><p>This object manages xkb bindings state associated with a specific seat.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_seat_v1.destroy href=#river_xkb_bindings_seat_v1.destroy>river_xkb_bindings_seat_v1.destroy</a></h3><p class=summary>destroy the object</div><div><b>Destructor
Request</b><br>Since Version 2</div></div></div><div class=description><p>This request indicates that the client will no longer use the object and
that it may be safely destroyed.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_seat_v1.ensure_next_key_eaten href=#river_xkb_bindings_seat_v1.ensure_next_key_eaten>river_xkb_bindings_seat_v1.ensure_next_key_eaten</a></h3><p class=summary>ensure the next key press event is eaten</div><div><b>Request</b><br>Since Version 2</div></div></div><div class=description><p>Ensure that the next non-modifier key press and corresponding release
events for this seat are not sent to the currently focused surface.<p>If the next non-modifier key press triggers a binding, the
pressed/released events are sent to the <b><a href=/docs/wayland/river-xkb-bindings-v1/#river_xkb_binding_v1>river_xkb_binding_v1</a></b> object as
usual.<p>If the next non-modifier key press does not trigger a binding, the
ate_unbound_key event is sent instead.<p>Rationale: the window manager may wish to implement "chorded"
keybindings where triggering a binding activates a "submap" with a
different set of keybindings. Without a way to eat the next key
press event, there is no good way for the window manager to know that it
should error out and exit the submap when a key not bound in the submap
is pressed.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_seat_v1.cancel_ensure_next_key_eaten href=#river_xkb_bindings_seat_v1.cancel_ensure_next_key_eaten>river_xkb_bindings_seat_v1.cancel_ensure_next_key_eaten</a></h3><p class=summary>cancel an ensure_next_key_eaten request</div><div><b>Request</b><br>Since Version 2</div></div></div><div class=description><p>This requests cancels the effect of the latest ensure_next_key_eaten
request if no key has been eaten due to the request yet. This request
has no effect if a key has already been eaten or no
ensure_next_key_eaten was made.<p>Rationale: the window manager may wish cancel an uncompleted "chorded"
keybinding after a timeout of a few seconds. Note that since this
timeout use-case requires the window manager to trigger a manage sequence
with the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1.manage_dirty>river_window_manager_v1.manage_dirty</a></b> request it is possible that
the ate_unbound_key key event may be sent before the window manager has
a chance to make the cancel_ensure_next_key_eaten request.<p>This request modifies window management state and may only be made as
part of a manage sequence, see the <b><a href=/docs/wayland/river-window-management-v1/#river_window_manager_v1>river_window_manager_v1</a></b> description.</div><div class=message-head><div class=row><div><h3><a id=river_xkb_bindings_seat_v1.ate_unbound_key href=#river_xkb_bindings_seat_v1.ate_unbound_key>river_xkb_bindings_seat_v1.ate_unbound_key</a></h3><p class=summary>an unbound key press event was eaten</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>An unbound key press event was eaten due to the ensure_next_key_eaten
request.<p>This event will be followed by a manage_start event after all other new
state has been sent by the server.</div><div class=interface-head><h2>Copyright</h2></div><div class=copyright><p><br>SPDX-FileCopyrightText: © 2025 Isaac Freund<br>SPDX-License-Identifier: MIT<br><br>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the "Software"), to<br>deal in the Software without restriction, including without limitation the<br>rights to use, copy, modify, merge, publish, distribute, sublicense, and/or<br>sell copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:<br><br>The above copyright notice and this permission notice shall be included in<br>all copies or substantial portions of the Software.<br><br>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br>FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br>IN THE SOFTWARE.<br></div></div></main><footer><span class=line>© 2021-2026 Isaac Freund,</span>
<span class=line><a href=/impressum>Impressum</a>,</span>
<span class=line>Content <a href=/CC-BY-NC-SA-4.0.txt>CC-BY-NC-SA-4.0</a>,</span>
<span class=line><a href=https://codeberg.org/ifreund/website>Source Code</a> <a href=/AGPL-3.0-only.txt>AGPL-3.0-only</a></span></footer>