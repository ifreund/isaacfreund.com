<!doctype html><html lang=en><meta name=viewport content="width=device-width,initial-scale=1"><title></title><link rel=icon href=/if.png><link rel=stylesheet href=/style.css><link rel=alternate href=/blog/feed.xml type=application/atom+xml title="Isaac Freund's Blog"><link rel=alternate href=/poetry/feed.xml type=application/atom+xml title="Isaac Freund's Poetry"><link rel=me href=https://hachyderm.io/@ifreund><header><nav><input type=checkbox id=toggle><div class=nav-bar><div class=nav-home><a href=/><svg viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="1" height="1"/><rect x="0" y="2" width="1" height="3"/><path d="M2 0h3v1H3v1h2v1H3v2H2V0z"/><rect x="4" y="4" width="1" height="1"/></svg></a></div><div class=menu><label for=toggle class=menu-button><svg class="menu-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="5" height="1"/><rect x="0" y="2" width="5" height="1"/><rect x="0" y="4" width="5" height="1"/></svg>
<svg class="close-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><line x1="0" y1="0" x2="5" y2="5"/><line x1="0" y1="5" x2="5" y2="0"/></svg></label></div></div></div><div class=nav-items><a href=/about>about</a>
<a href=/blog>blog</a>
<a href=/software>software</a>
<a href=/poetry>poetry</a>
<a href=/consulting>consulting</a></div></nav></header><main class="wayland-protocol wayland"><div class=title><h1>wayland</h1><p class=summary></div><div class=content><div class=interface-head><div class=row><div><h2><a id=wl_display href=#wl_display>wl_display</a></h2><p class=summary>core global object</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>The core global object. This is a special singleton object. It
is used for internal Wayland protocol features.</div><div class=message-head><div class=row><div><h3><a id=wl_display.sync href=#wl_display.sync>wl_display.sync</a></h3><p class=summary>asynchronous roundtrip</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>The sync request asks the server to emit the 'done' event
on the returned <b><a href=/docs/wayland/wayland/#wl_callback>wl_callback</a></b> object. Since requests are
handled in-order and events are delivered in-order, this can
be used as a barrier to ensure all previous requests and the
resulting events have been handled.<p>The object returned by this request will be destroyed by the
compositor after the callback is fired and as such the client must not
attempt to use it after that point.<p>The callback_data passed in the callback is undefined and should be ignored.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>callback<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_callback>wl_callback</a></b>><td><p>callback object for the sync request</table><div class=message-head><div class=row><div><h3><a id=wl_display.get_registry href=#wl_display.get_registry>wl_display.get_registry</a></h3><p class=summary>get global registry object</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request creates a registry object that allows the client
to list and bind the global objects available from the
compositor.<p>It should be noted that the server side resources consumed in
response to a get_registry request can only be released when the
client disconnects, not when the client side proxy is destroyed.
Therefore, clients should invoke get_registry as infrequently as
possible to avoid wasting memory.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>registry<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_registry>wl_registry</a></b>><td><p>global registry object</table><div class=message-head><div class=row><div><h3><a id=wl_display.error href=#wl_display.error>wl_display.error</a></h3><p class=summary>fatal error event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The error event is sent out when a fatal (non-recoverable)
error has occurred. The object_id argument is the object
where the error occurred, most often in response to a request
to that object. The code identifies the error and is defined
by the object interface. As such, each interface defines its
own set of error codes. The message is a brief description
of the error, for (debugging) convenience.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>object_id<td>object<td><p>object where the error occurred<tr><td>code<td>uint<td><p>error code<tr><td>message<td>string<td><p>error description</table><div class=message-head><div class=row><div><h3><a id=wl_display.delete_id href=#wl_display.delete_id>wl_display.delete_id</a></h3><p class=summary>acknowledge object ID deletion</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event is used internally by the object ID management
logic. When a client deletes an object that it had created,
the server will send this event to acknowledge that it has
seen the delete request. When the client receives this event,
it will know that it can safely reuse the object ID.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>uint<td><p>deleted object ID</table><div class=message-head><div class=row><div><h3><a id=wl_display.enums.error href=#wl_display.enums.error>wl_display.error</a></h3><p class=summary>global error values</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>These errors are global and can be emitted in response to any
server request.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>invalid_object<td>0<td>1<td><p>server couldn't find object<tr><td>invalid_method<td>1<td>1<td><p>method doesn't exist on the specified interface or malformed request<tr><td>no_memory<td>2<td>1<td><p>server is out of memory<tr><td>implementation<td>3<td>1<td><p>implementation error in compositor</table><div class=interface-head><div class=row><div><h2><a id=wl_registry href=#wl_registry>wl_registry</a></h2><p class=summary>global registry object</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>The singleton global registry object. The server has a number of
global objects that are available to all clients. These objects
typically represent an actual object in the server (for example,
an input device) or they are singleton objects that provide
extension functionality.<p>When a client creates a registry object, the registry object
will emit a global event for each global currently in the
registry. Globals come and go as a result of device or
monitor hotplugs, reconfiguration or other events, and the
registry will send out global and global_remove events to
keep the client up to date with the changes. To mark the end
of the initial burst of events, the client can use the
<b><a href=/docs/wayland/wayland/#wl_display.sync>wl_display.sync</a></b> request immediately after calling
<b><a href=/docs/wayland/wayland/#wl_display.get_registry>wl_display.get_registry</a></b>.<p>A client can bind to a global object by using the bind
request. This creates a client-side handle that lets the object
emit events to the client and lets the client invoke requests on
the object.</div><div class=message-head><div class=row><div><h3><a id=wl_registry.bind href=#wl_registry.bind>wl_registry.bind</a></h3><p class=summary>bind an object to the display</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Binds a new, client-created object to the server using the
specified name as the identifier.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>uint<td><p>unique numeric name of the object<tr><td>id<td>new_id<td><p>bounded object</table><div class=message-head><div class=row><div><h3><a id=wl_registry.global href=#wl_registry.global>wl_registry.global</a></h3><p class=summary>announce global object</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notify the client of global objects.<p>The event notifies the client that a global object with
the given name is now available, and it implements the
given version of the given interface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>uint<td><p>numeric name of the global object<tr><td>interface<td>string<td><p>interface implemented by the object<tr><td>version<td>uint<td><p>interface version</table><div class=message-head><div class=row><div><h3><a id=wl_registry.global_remove href=#wl_registry.global_remove>wl_registry.global_remove</a></h3><p class=summary>announce removal of global object</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notify the client of removed global objects.<p>This event notifies the client that the global identified
by name is no longer available. If the client bound to
the global using the bind request, the client should now
destroy that object.<p>The object remains valid and requests to the object will be
ignored until the client destroys it, to avoid races between
the global going away and a client sending a request to it.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>uint<td><p>numeric name of the global object</table><div class=interface-head><div class=row><div><h2><a id=wl_callback href=#wl_callback>wl_callback</a></h2><p class=summary>callback object</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>Clients can handle the 'done' event to get notified when
the related request is done.<p>Note, because <b><a href=/docs/wayland/wayland/#wl_callback>wl_callback</a></b> objects are created from multiple independent
factory interfaces, the <b><a href=/docs/wayland/wayland/#wl_callback>wl_callback</a></b> interface is frozen at version 1.</div><div class=message-head><div class=row><div><h3><a id=wl_callback.done href=#wl_callback.done>wl_callback.done</a></h3><p class=summary>done event</div><div><b>Destructor
Event</b><br>Since Version 1</div></div></div><div class=description><p>Notify the client when the related request is done.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>callback_data<td>uint<td><p>request-specific data for the callback</table><div class=interface-head><div class=row><div><h2><a id=wl_compositor href=#wl_compositor>wl_compositor</a></h2><p class=summary>the compositor singleton</div><div><b>Interface</b><br>Version 6</div></div></div><div class=description><p>A compositor. This object is a singleton global. The
compositor is in charge of combining the contents of multiple
surfaces into one displayable output.</div><div class=message-head><div class=row><div><h3><a id=wl_compositor.create_surface href=#wl_compositor.create_surface>wl_compositor.create_surface</a></h3><p class=summary>create new surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Ask the compositor to create a new surface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>the new surface</table><div class=message-head><div class=row><div><h3><a id=wl_compositor.create_region href=#wl_compositor.create_region>wl_compositor.create_region</a></h3><p class=summary>create new region</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Ask the compositor to create a new region.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b>><td><p>the new region</table><div class=interface-head><div class=row><div><h2><a id=wl_shm_pool href=#wl_shm_pool>wl_shm_pool</a></h2><p class=summary>a shared memory pool</div><div><b>Interface</b><br>Version 2</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_shm_pool>wl_shm_pool</a></b> object encapsulates a piece of memory shared
between the compositor and client. Through the <b><a href=/docs/wayland/wayland/#wl_shm_pool>wl_shm_pool</a></b>
object, the client can allocate shared memory <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> objects.
All objects created through the same pool share the same
underlying mapped memory. Reusing the mapped memory avoids the
setup/teardown overhead and is useful when interactively resizing
a surface or for many small buffers.</div><div class=message-head><div class=row><div><h3><a id=wl_shm_pool.create_buffer href=#wl_shm_pool.create_buffer>wl_shm_pool.create_buffer</a></h3><p class=summary>create a buffer from the pool</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> object from the pool.<p>The buffer is created offset bytes into the pool and has
width and height as specified. The stride argument specifies
the number of bytes from the beginning of one row to the beginning
of the next. The format is the pixel format of the buffer and
must be one of those advertised through the <b><a href=/docs/wayland/wayland/#wl_shm.format>wl_shm.format</a></b> event.<p>A buffer will keep a reference to the pool it was created from
so it is valid to destroy the pool immediately after creating
a buffer from it.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>><td><p>buffer to create<tr><td>offset<td>int<td><p>buffer byte offset within the pool<tr><td>width<td>int<td><p>buffer width, in pixels<tr><td>height<td>int<td><p>buffer height, in pixels<tr><td>stride<td>int<td><p>number of bytes from the beginning of one row to the beginning of the next row<tr><td>format<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shm.enums.format>wl_shm.format</a></b>><td><p>buffer pixel format</table><div class=message-head><div class=row><div><h3><a id=wl_shm_pool.destroy href=#wl_shm_pool.destroy>wl_shm_pool.destroy</a></h3><p class=summary>destroy the pool</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Destroy the shared memory pool.<p>The mmapped memory will be released when all
buffers that have been created from this pool
are gone.</div><div class=message-head><div class=row><div><h3><a id=wl_shm_pool.resize href=#wl_shm_pool.resize>wl_shm_pool.resize</a></h3><p class=summary>change the size of the pool mapping</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request will cause the server to remap the backing memory
for the pool from the file descriptor passed when the pool was
created, but using the new size. This request can only be
used to make the pool bigger.<p>This request only changes the amount of bytes that are mmapped
by the server and does not touch the file corresponding to the
file descriptor passed at creation time. It is the client's
responsibility to ensure that the file is at least as big as
the new pool size.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>size<td>int<td><p>new size of the pool, in bytes</table><div class=interface-head><div class=row><div><h2><a id=wl_shm href=#wl_shm>wl_shm</a></h2><p class=summary>shared memory support</div><div><b>Interface</b><br>Version 2</div></div></div><div class=description><p>A singleton global object that provides support for shared
memory.<p>Clients can create <b><a href=/docs/wayland/wayland/#wl_shm_pool>wl_shm_pool</a></b> objects using the create_pool
request.<p>On binding the <b><a href=/docs/wayland/wayland/#wl_shm>wl_shm</a></b> object one or more format events
are emitted to inform clients about the valid pixel formats
that can be used for buffers.</div><div class=message-head><div class=row><div><h3><a id=wl_shm.create_pool href=#wl_shm.create_pool>wl_shm.create_pool</a></h3><p class=summary>create a shm pool</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a new <b><a href=/docs/wayland/wayland/#wl_shm_pool>wl_shm_pool</a></b> object.<p>The pool can be used to create shared memory based buffer
objects. The server will mmap size bytes of the passed file
descriptor, to use as backing memory for the pool.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_shm_pool>wl_shm_pool</a></b>><td><p>pool to create<tr><td>fd<td>fd<td><p>file descriptor for the pool<tr><td>size<td>int<td><p>pool size, in bytes</table><div class=message-head><div class=row><div><h3><a id=wl_shm.release href=#wl_shm.release>wl_shm.release</a></h3><p class=summary>release the shm object</div><div><b>Destructor
Request</b><br>Since Version 2</div></div></div><div class=description><p>Using this request a client can tell the server that it is not going to
use the shm object anymore.<p>Objects created via this interface remain unaffected.</div><div class=message-head><div class=row><div><h3><a id=wl_shm.format href=#wl_shm.format>wl_shm.format</a></h3><p class=summary>pixel format description</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Informs the client about a valid pixel format that
can be used for buffers. Known formats include
argb8888 and xrgb8888.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>format<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shm.enums.format>format</a></b>><td><p>buffer pixel format</table><div class=message-head><div class=row><div><h3><a id=wl_shm.enums.error href=#wl_shm.enums.error>wl_shm.error</a></h3><p class=summary>wl_shm error values</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>These errors can be emitted in response to <b><a href=/docs/wayland/wayland/#wl_shm>wl_shm</a></b> requests.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>invalid_format<td>0<td>1<td><p>buffer format is not known<tr><td>invalid_stride<td>1<td>1<td><p>invalid size or stride during pool or buffer creation<tr><td>invalid_fd<td>2<td>1<td><p>mmapping the file descriptor failed</table><div class=message-head><div class=row><div><h3><a id=wl_shm.enums.format href=#wl_shm.enums.format>wl_shm.format</a></h3><p class=summary>pixel formats</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>This describes the memory layout of an individual pixel.<p>All renderers should support argb8888 and xrgb8888 but any other
formats are optional and may not be supported by the particular
renderer in use.<p>The drm format codes match the macros defined in drm_fourcc.h, except
argb8888 and xrgb8888. The formats actually supported by the compositor
will be reported by the format event.<p>For all <b><a href=/docs/wayland/wayland/#wl_shm>wl_shm</a></b> formats and unless specified in another protocol
extension, pre-multiplied alpha is used for pixel values.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>argb8888<td>0<td>1<td><p>32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian<tr><td>xrgb8888<td>1<td>1<td><p>32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian<tr><td>c8<td>0x20203843<td>1<td><p>8-bit color index format, [7:0] C<tr><td>rgb332<td>0x38424752<td>1<td><p>8-bit RGB format, [7:0] R:G:B 3:3:2<tr><td>bgr233<td>0x38524742<td>1<td><p>8-bit BGR format, [7:0] B:G:R 2:3:3<tr><td>xrgb4444<td>0x32315258<td>1<td><p>16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian<tr><td>xbgr4444<td>0x32314258<td>1<td><p>16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian<tr><td>rgbx4444<td>0x32315852<td>1<td><p>16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian<tr><td>bgrx4444<td>0x32315842<td>1<td><p>16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian<tr><td>argb4444<td>0x32315241<td>1<td><p>16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian<tr><td>abgr4444<td>0x32314241<td>1<td><p>16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian<tr><td>rgba4444<td>0x32314152<td>1<td><p>16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian<tr><td>bgra4444<td>0x32314142<td>1<td><p>16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian<tr><td>xrgb1555<td>0x35315258<td>1<td><p>16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian<tr><td>xbgr1555<td>0x35314258<td>1<td><p>16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian<tr><td>rgbx5551<td>0x35315852<td>1<td><p>16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian<tr><td>bgrx5551<td>0x35315842<td>1<td><p>16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian<tr><td>argb1555<td>0x35315241<td>1<td><p>16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian<tr><td>abgr1555<td>0x35314241<td>1<td><p>16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian<tr><td>rgba5551<td>0x35314152<td>1<td><p>16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian<tr><td>bgra5551<td>0x35314142<td>1<td><p>16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian<tr><td>rgb565<td>0x36314752<td>1<td><p>16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian<tr><td>bgr565<td>0x36314742<td>1<td><p>16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian<tr><td>rgb888<td>0x34324752<td>1<td><p>24-bit RGB format, [23:0] R:G:B little endian<tr><td>bgr888<td>0x34324742<td>1<td><p>24-bit BGR format, [23:0] B:G:R little endian<tr><td>xbgr8888<td>0x34324258<td>1<td><p>32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian<tr><td>rgbx8888<td>0x34325852<td>1<td><p>32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian<tr><td>bgrx8888<td>0x34325842<td>1<td><p>32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian<tr><td>abgr8888<td>0x34324241<td>1<td><p>32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian<tr><td>rgba8888<td>0x34324152<td>1<td><p>32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian<tr><td>bgra8888<td>0x34324142<td>1<td><p>32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian<tr><td>xrgb2101010<td>0x30335258<td>1<td><p>32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian<tr><td>xbgr2101010<td>0x30334258<td>1<td><p>32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian<tr><td>rgbx1010102<td>0x30335852<td>1<td><p>32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian<tr><td>bgrx1010102<td>0x30335842<td>1<td><p>32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian<tr><td>argb2101010<td>0x30335241<td>1<td><p>32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian<tr><td>abgr2101010<td>0x30334241<td>1<td><p>32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian<tr><td>rgba1010102<td>0x30334152<td>1<td><p>32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian<tr><td>bgra1010102<td>0x30334142<td>1<td><p>32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian<tr><td>yuyv<td>0x56595559<td>1<td><p>packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian<tr><td>yvyu<td>0x55595659<td>1<td><p>packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian<tr><td>uyvy<td>0x59565955<td>1<td><p>packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian<tr><td>vyuy<td>0x59555956<td>1<td><p>packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian<tr><td>ayuv<td>0x56555941<td>1<td><p>packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian<tr><td>nv12<td>0x3231564e<td>1<td><p>2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane<tr><td>nv21<td>0x3132564e<td>1<td><p>2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane<tr><td>nv16<td>0x3631564e<td>1<td><p>2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane<tr><td>nv61<td>0x3136564e<td>1<td><p>2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane<tr><td>yuv410<td>0x39565559<td>1<td><p>3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes<tr><td>yvu410<td>0x39555659<td>1<td><p>3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes<tr><td>yuv411<td>0x31315559<td>1<td><p>3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes<tr><td>yvu411<td>0x31315659<td>1<td><p>3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes<tr><td>yuv420<td>0x32315559<td>1<td><p>3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes<tr><td>yvu420<td>0x32315659<td>1<td><p>3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes<tr><td>yuv422<td>0x36315559<td>1<td><p>3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes<tr><td>yvu422<td>0x36315659<td>1<td><p>3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes<tr><td>yuv444<td>0x34325559<td>1<td><p>3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes<tr><td>yvu444<td>0x34325659<td>1<td><p>3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes<tr><td>r8<td>0x20203852<td>1<td><p>[7:0] R<tr><td>r16<td>0x20363152<td>1<td><p>[15:0] R little endian<tr><td>rg88<td>0x38384752<td>1<td><p>[15:0] R:G 8:8 little endian<tr><td>gr88<td>0x38385247<td>1<td><p>[15:0] G:R 8:8 little endian<tr><td>rg1616<td>0x32334752<td>1<td><p>[31:0] R:G 16:16 little endian<tr><td>gr1616<td>0x32335247<td>1<td><p>[31:0] G:R 16:16 little endian<tr><td>xrgb16161616f<td>0x48345258<td>1<td><p>[63:0] x:R:G:B 16:16:16:16 little endian<tr><td>xbgr16161616f<td>0x48344258<td>1<td><p>[63:0] x:B:G:R 16:16:16:16 little endian<tr><td>argb16161616f<td>0x48345241<td>1<td><p>[63:0] A:R:G:B 16:16:16:16 little endian<tr><td>abgr16161616f<td>0x48344241<td>1<td><p>[63:0] A:B:G:R 16:16:16:16 little endian<tr><td>xyuv8888<td>0x56555958<td>1<td><p>[31:0] X:Y:Cb:Cr 8:8:8:8 little endian<tr><td>vuy888<td>0x34325556<td>1<td><p>[23:0] Cr:Cb:Y 8:8:8 little endian<tr><td>vuy101010<td>0x30335556<td>1<td><p>Y followed by U then V, 10:10:10. Non-linear modifier only<tr><td>y210<td>0x30313259<td>1<td><p>[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels<tr><td>y212<td>0x32313259<td>1<td><p>[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels<tr><td>y216<td>0x36313259<td>1<td><p>[63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels<tr><td>y410<td>0x30313459<td>1<td><p>[31:0] A:Cr:Y:Cb 2:10:10:10 little endian<tr><td>y412<td>0x32313459<td>1<td><p>[63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian<tr><td>y416<td>0x36313459<td>1<td><p>[63:0] A:Cr:Y:Cb 16:16:16:16 little endian<tr><td>xvyu2101010<td>0x30335658<td>1<td><p>[31:0] X:Cr:Y:Cb 2:10:10:10 little endian<tr><td>xvyu12_16161616<td>0x36335658<td>1<td><p>[63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian<tr><td>xvyu16161616<td>0x38345658<td>1<td><p>[63:0] X:Cr:Y:Cb 16:16:16:16 little endian<tr><td>y0l0<td>0x304c3059<td>1<td><p>[63:0] A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian<tr><td>x0l0<td>0x304c3058<td>1<td><p>[63:0] X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian<tr><td>y0l2<td>0x324c3059<td>1<td><p>[63:0] A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian<tr><td>x0l2<td>0x324c3058<td>1<td><p>[63:0] X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian<tr><td>yuv420_8bit<td>0x38305559<td>1<td><p><tr><td>yuv420_10bit<td>0x30315559<td>1<td><p><tr><td>xrgb8888_a8<td>0x38415258<td>1<td><p><tr><td>xbgr8888_a8<td>0x38414258<td>1<td><p><tr><td>rgbx8888_a8<td>0x38415852<td>1<td><p><tr><td>bgrx8888_a8<td>0x38415842<td>1<td><p><tr><td>rgb888_a8<td>0x38413852<td>1<td><p><tr><td>bgr888_a8<td>0x38413842<td>1<td><p><tr><td>rgb565_a8<td>0x38413552<td>1<td><p><tr><td>bgr565_a8<td>0x38413542<td>1<td><p><tr><td>nv24<td>0x3432564e<td>1<td><p>non-subsampled Cr:Cb plane<tr><td>nv42<td>0x3234564e<td>1<td><p>non-subsampled Cb:Cr plane<tr><td>p210<td>0x30313250<td>1<td><p>2x1 subsampled Cr:Cb plane, 10 bit per channel<tr><td>p010<td>0x30313050<td>1<td><p>2x2 subsampled Cr:Cb plane 10 bits per channel<tr><td>p012<td>0x32313050<td>1<td><p>2x2 subsampled Cr:Cb plane 12 bits per channel<tr><td>p016<td>0x36313050<td>1<td><p>2x2 subsampled Cr:Cb plane 16 bits per channel<tr><td>axbxgxrx106106106106<td>0x30314241<td>1<td><p>[63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian<tr><td>nv15<td>0x3531564e<td>1<td><p>2x2 subsampled Cr:Cb plane<tr><td>q410<td>0x30313451<td>1<td><p><tr><td>q401<td>0x31303451<td>1<td><p><tr><td>xrgb16161616<td>0x38345258<td>1<td><p>[63:0] x:R:G:B 16:16:16:16 little endian<tr><td>xbgr16161616<td>0x38344258<td>1<td><p>[63:0] x:B:G:R 16:16:16:16 little endian<tr><td>argb16161616<td>0x38345241<td>1<td><p>[63:0] A:R:G:B 16:16:16:16 little endian<tr><td>abgr16161616<td>0x38344241<td>1<td><p>[63:0] A:B:G:R 16:16:16:16 little endian<tr><td>c1<td>0x20203143<td>1<td><p>[7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte<tr><td>c2<td>0x20203243<td>1<td><p>[7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte<tr><td>c4<td>0x20203443<td>1<td><p>[7:0] C0:C1 4:4 two pixels/byte<tr><td>d1<td>0x20203144<td>1<td><p>[7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte<tr><td>d2<td>0x20203244<td>1<td><p>[7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte<tr><td>d4<td>0x20203444<td>1<td><p>[7:0] D0:D1 4:4 two pixels/byte<tr><td>d8<td>0x20203844<td>1<td><p>[7:0] D<tr><td>r1<td>0x20203152<td>1<td><p>[7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte<tr><td>r2<td>0x20203252<td>1<td><p>[7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte<tr><td>r4<td>0x20203452<td>1<td><p>[7:0] R0:R1 4:4 two pixels/byte<tr><td>r10<td>0x20303152<td>1<td><p>[15:0] x:R 6:10 little endian<tr><td>r12<td>0x20323152<td>1<td><p>[15:0] x:R 4:12 little endian<tr><td>avuy8888<td>0x59555641<td>1<td><p>[31:0] A:Cr:Cb:Y 8:8:8:8 little endian<tr><td>xvuy8888<td>0x59555658<td>1<td><p>[31:0] X:Cr:Cb:Y 8:8:8:8 little endian<tr><td>p030<td>0x30333050<td>1<td><p>2x2 subsampled Cr:Cb plane 10 bits per channel packed<tr><td>rgb161616<td>0x38344752<td>1<td><p>[47:0] R:G:B 16:16:16 little endian<tr><td>bgr161616<td>0x38344742<td>1<td><p>[47:0] B:G:R 16:16:16 little endian<tr><td>r16f<td>0x48202052<td>1<td><p>[15:0] R 16 little endian<tr><td>gr1616f<td>0x48205247<td>1<td><p>[31:0] G:R 16:16 little endian<tr><td>bgr161616f<td>0x48524742<td>1<td><p>[47:0] B:G:R 16:16:16 little endian<tr><td>r32f<td>0x46202052<td>1<td><p>[31:0] R 32 little endian<tr><td>gr3232f<td>0x46205247<td>1<td><p>[63:0] R:G 32:32 little endian<tr><td>bgr323232f<td>0x46524742<td>1<td><p>[95:0] R:G:B 32:32:32 little endian<tr><td>abgr32323232f<td>0x46384241<td>1<td><p>[127:0] R:G:B:A 32:32:32:32 little endian<tr><td>nv20<td>0x3032564e<td>1<td><p>2x1 subsampled Cr:Cb plane<tr><td>nv30<td>0x3033564e<td>1<td><p>non-subsampled Cr:Cb plane<tr><td>s010<td>0x30313053<td>1<td><p>2x2 subsampled Cb (1) and Cr (2) planes 10 bits per channel<tr><td>s210<td>0x30313253<td>1<td><p>2x1 subsampled Cb (1) and Cr (2) planes 10 bits per channel<tr><td>s410<td>0x30313453<td>1<td><p>non-subsampled Cb (1) and Cr (2) planes 10 bits per channel<tr><td>s012<td>0x32313053<td>1<td><p>2x2 subsampled Cb (1) and Cr (2) planes 12 bits per channel<tr><td>s212<td>0x32313253<td>1<td><p>2x1 subsampled Cb (1) and Cr (2) planes 12 bits per channel<tr><td>s412<td>0x32313453<td>1<td><p>non-subsampled Cb (1) and Cr (2) planes 12 bits per channel<tr><td>s016<td>0x36313053<td>1<td><p>2x2 subsampled Cb (1) and Cr (2) planes 16 bits per channel<tr><td>s216<td>0x36313253<td>1<td><p>2x1 subsampled Cb (1) and Cr (2) planes 16 bits per channel<tr><td>s416<td>0x36313453<td>1<td><p>non-subsampled Cb (1) and Cr (2) planes 16 bits per channel</table><div class=interface-head><div class=row><div><h2><a id=wl_buffer href=#wl_buffer>wl_buffer</a></h2><p class=summary>content for a wl_surface</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>A buffer provides the content for a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>. Buffers are
created through factory interfaces such as <b><a href=/docs/wayland/wayland/#wl_shm>wl_shm</a></b>, wp_linux_buffer_params
(from the linux-dmabuf protocol extension) or similar. It has a width and
a height and can be attached to a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, but the mechanism by which a
client provides and updates the contents is defined by the buffer factory
interface.<p>Color channels are assumed to be electrical rather than optical (in other
words, encoded with a transfer function) unless otherwise specified. If
the buffer uses a format that has an alpha channel, the alpha channel is
assumed to be premultiplied into the electrical color channel values
(after transfer function encoding) unless otherwise specified.<p>Note, because <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> objects are created from multiple independent
factory interfaces, the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> interface is frozen at version 1.</div><div class=message-head><div class=row><div><h3><a id=wl_buffer.destroy href=#wl_buffer.destroy>wl_buffer.destroy</a></h3><p class=summary>destroy a buffer</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Destroy a buffer. If and how you need to release the backing
storage is defined by the buffer factory interface.<p>For possible side-effects to a surface, see <b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b>.</div><div class=message-head><div class=row><div><h3><a id=wl_buffer.release href=#wl_buffer.release>wl_buffer.release</a></h3><p class=summary>compositor releases buffer</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Sent when this <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> is no longer used by the compositor.<p>For more information on when release events may or may not be sent,
and what consequences it has, please see the description of
<b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b>.<p>If a client receives a release event before the frame callback
requested in the same <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> that attaches this
<b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> to a surface, then the client is immediately free to
reuse the buffer and its backing storage, and does not need a
second buffer for the next surface content update. Typically
this is possible, when the compositor maintains a copy of the
<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> contents, e.g. as a GL texture. This is an important
optimization for GL(ES) compositors with <b><a href=/docs/wayland/wayland/#wl_shm>wl_shm</a></b> clients.</div><div class=interface-head><div class=row><div><h2><a id=wl_data_offer href=#wl_data_offer>wl_data_offer</a></h2><p class=summary>offer to transfer data</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>A <b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b> represents a piece of data offered for transfer
by another client (the source client). It is used by the
copy-and-paste and drag-and-drop mechanisms. The offer
describes the different mime types that the data can be
converted to and provides the mechanism for transferring the
data directly from the source client.</div><div class=message-head><div class=row><div><h3><a id=wl_data_offer.accept href=#wl_data_offer.accept>wl_data_offer.accept</a></h3><p class=summary>accept one of the offered mime types</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Indicate that the client can accept the given mime type, or
NULL for not accepted.<p>For objects of version 2 or older, this request is used by the
client to give feedback whether the client can receive the given
mime type, or NULL if none is accepted; the feedback does not
determine whether the drag-and-drop operation succeeds or not.<p>For objects of version 3 or newer, this request determines the
final result of the drag-and-drop operation. If the end result
is that no mime types were accepted, the drag-and-drop operation
will be cancelled and the corresponding drag source will receive
<b><a href=/docs/wayland/wayland/#wl_data_source.cancelled>wl_data_source.cancelled</a></b>. Clients may still use this event in
conjunction with <b><a href=/docs/wayland/wayland/#wl_data_source.action>wl_data_source.action</a></b> for feedback.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the accept request<tr><td>mime_type<td>nullable
string<td><p>mime type accepted by the client</table><div class=message-head><div class=row><div><h3><a id=wl_data_offer.receive href=#wl_data_offer.receive>wl_data_offer.receive</a></h3><p class=summary>request that the data is transferred</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>To transfer the offered data, the client issues this request
and indicates the mime type it wants to receive. The transfer
happens through the passed file descriptor (typically created
with the pipe system call). The source client writes the data
in the mime type representation requested and then closes the
file descriptor.<p>The receiving client reads from the read end of the pipe until
EOF and then closes its end, at which point the transfer is
complete.<p>This request may happen multiple times for different mime types,
both before and after <b><a href=/docs/wayland/wayland/#wl_data_device.drop>wl_data_device.drop</a></b>. Drag-and-drop destination
clients may preemptively fetch data or examine it more closely to
determine acceptance.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>mime_type<td>string<td><p>mime type desired by receiver<tr><td>fd<td>fd<td><p>file descriptor for data transfer</table><div class=message-head><div class=row><div><h3><a id=wl_data_offer.destroy href=#wl_data_offer.destroy>wl_data_offer.destroy</a></h3><p class=summary>destroy data offer</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Destroy the data offer.</div><div class=message-head><div class=row><div><h3><a id=wl_data_offer.finish href=#wl_data_offer.finish>wl_data_offer.finish</a></h3><p class=summary>the offer will no longer be used</div><div><b>Request</b><br>Since Version 3</div></div></div><div class=description><p>Notifies the compositor that the drag destination successfully
finished the drag-and-drop operation.<p>Upon receiving this request, the compositor will emit
<b><a href=/docs/wayland/wayland/#wl_data_source.dnd_finished>wl_data_source.dnd_finished</a></b> on the drag source client.<p>It is a client error to perform other requests than
<b><a href=/docs/wayland/wayland/#wl_data_offer.destroy>wl_data_offer.destroy</a></b> after this one. It is also an error to perform
this request after a NULL mime type has been set in
<b><a href=/docs/wayland/wayland/#wl_data_offer.accept>wl_data_offer.accept</a></b> or no action was received through
<b><a href=/docs/wayland/wayland/#wl_data_offer.action>wl_data_offer.action</a></b>.<p>If <b><a href=/docs/wayland/wayland/#wl_data_offer.finish>wl_data_offer.finish</a></b> request is received for a non drag and drop
operation, the invalid_finish protocol error is raised.</div><div class=message-head><div class=row><div><h3><a id=wl_data_offer.set_actions href=#wl_data_offer.set_actions>wl_data_offer.set_actions</a></h3><p class=summary>set the available/preferred drag-and-drop actions</div><div><b>Request</b><br>Since Version 3</div></div></div><div class=description><p>Sets the actions that the destination side client supports for
this operation. This request may trigger the emission of
<b><a href=/docs/wayland/wayland/#wl_data_source.action>wl_data_source.action</a></b> and <b><a href=/docs/wayland/wayland/#wl_data_offer.action>wl_data_offer.action</a></b> events if the compositor
needs to change the selected action.<p>This request can be called multiple times throughout the
drag-and-drop operation, typically in response to <b><a href=/docs/wayland/wayland/#wl_data_device.enter>wl_data_device.enter</a></b>
or <b><a href=/docs/wayland/wayland/#wl_data_device.motion>wl_data_device.motion</a></b> events.<p>This request determines the final result of the drag-and-drop
operation. If the end result is that no action is accepted,
the drag source will receive <b><a href=/docs/wayland/wayland/#wl_data_source.cancelled>wl_data_source.cancelled</a></b>.<p>The dnd_actions argument must contain only values expressed in the
<b><a href=/docs/wayland/wayland/#></a></b>enum, and the preferred_action
argument must only contain one of those values set, otherwise it
will result in a protocol error.<p>While managing an "ask" action, the destination drag-and-drop client
may perform further <b><a href=/docs/wayland/wayland/#wl_data_offer.receive>wl_data_offer.receive</a></b> requests, and is expected
to perform one last <b><a href=/docs/wayland/wayland/#wl_data_offer.set_actions>wl_data_offer.set_actions</a></b> request with a preferred
action other than "ask" (and optionally <b><a href=/docs/wayland/wayland/#wl_data_offer.accept>wl_data_offer.accept</a></b>) before
requesting <b><a href=/docs/wayland/wayland/#wl_data_offer.finish>wl_data_offer.finish</a></b>, in order to convey the action selected
by the user. If the preferred action is not in the
<b><a href=/docs/wayland/wayland/#wl_data_offer.source_actions>wl_data_offer.source_actions</a></b> mask, an error will be raised.<p>If the "ask" action is dismissed (e.g. user cancellation), the client
is expected to perform <b><a href=/docs/wayland/wayland/#wl_data_offer.destroy>wl_data_offer.destroy</a></b> right away.<p>This request can only be made on drag-and-drop offers, a protocol error
will be raised otherwise.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>dnd_actions<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></b>><td><p>actions supported by the destination client<tr><td>preferred_action<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></b>><td><p>action preferred by the destination client</table><div class=message-head><div class=row><div><h3><a id=wl_data_offer.offer href=#wl_data_offer.offer>wl_data_offer.offer</a></h3><p class=summary>advertise offered mime type</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Sent immediately after creating the <b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b> object. One
event per offered mime type.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>mime_type<td>string<td><p>offered mime type</table><div class=message-head><div class=row><div><h3><a id=wl_data_offer.source_actions href=#wl_data_offer.source_actions>wl_data_offer.source_actions</a></h3><p class=summary>notify the source-side available actions</div><div><b>Event</b><br>Since Version 3</div></div></div><div class=description><p>This event indicates the actions offered by the data source. It
will be sent immediately after creating the <b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b> object,
or anytime the source side changes its offered actions through
<b><a href=/docs/wayland/wayland/#wl_data_source.set_actions>wl_data_source.set_actions</a></b>.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>source_actions<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></b>><td><p>actions offered by the data source</table><div class=message-head><div class=row><div><h3><a id=wl_data_offer.action href=#wl_data_offer.action>wl_data_offer.action</a></h3><p class=summary>notify the selected action</div><div><b>Event</b><br>Since Version 3</div></div></div><div class=description><p>This event indicates the action selected by the compositor after
matching the source/destination side actions. Only one action (or
none) will be offered here.<p>This event can be emitted multiple times during the drag-and-drop
operation in response to destination side action changes through
<b><a href=/docs/wayland/wayland/#wl_data_offer.set_actions>wl_data_offer.set_actions</a></b>.<p>This event will no longer be emitted after <b><a href=/docs/wayland/wayland/#wl_data_device.drop>wl_data_device.drop</a></b>
happened on the drag-and-drop destination, the client must
honor the last action received, or the last preferred one set
through <b><a href=/docs/wayland/wayland/#wl_data_offer.set_actions>wl_data_offer.set_actions</a></b> when handling an "ask" action.<p>Compositors may also change the selected action on the fly, mainly
in response to keyboard modifier changes during the drag-and-drop
operation.<p>The most recent action received is always the valid one. Prior to
receiving <b><a href=/docs/wayland/wayland/#wl_data_device.drop>wl_data_device.drop</a></b>, the chosen action may change (e.g.
due to keyboard modifiers being pressed). At the time of receiving
<b><a href=/docs/wayland/wayland/#wl_data_device.drop>wl_data_device.drop</a></b> the drag-and-drop destination must honor the
last action received.<p>Action changes may still happen after <b><a href=/docs/wayland/wayland/#wl_data_device.drop>wl_data_device.drop</a></b>,
especially on "ask" actions, where the drag-and-drop destination
may choose another action afterwards. Action changes happening
at this stage are always the result of inter-client negotiation, the
compositor shall no longer be able to induce a different action.<p>Upon "ask" actions, it is expected that the drag-and-drop destination
may potentially choose a different action and/or mime type,
based on <b><a href=/docs/wayland/wayland/#wl_data_offer.source_actions>wl_data_offer.source_actions</a></b> and finally chosen by the
user (e.g. popping up a menu with the available options). The
final <b><a href=/docs/wayland/wayland/#wl_data_offer.set_actions>wl_data_offer.set_actions</a></b> and <b><a href=/docs/wayland/wayland/#wl_data_offer.accept>wl_data_offer.accept</a></b> requests
must happen before the call to <b><a href=/docs/wayland/wayland/#wl_data_offer.finish>wl_data_offer.finish</a></b>.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>dnd_action<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></b>><td><p>action selected by the compositor</table><div class=message-head><div class=row><div><h3><a id=wl_data_offer.enums.error href=#wl_data_offer.enums.error>wl_data_offer.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>invalid_finish<td>0<td>1<td><p>finish request was called untimely<tr><td>invalid_action_mask<td>1<td>1<td><p>action mask contains invalid values<tr><td>invalid_action<td>2<td>1<td><p>action argument has an invalid value<tr><td>invalid_offer<td>3<td>1<td><p>offer doesn't accept this request</table><div class=interface-head><div class=row><div><h2><a id=wl_data_source href=#wl_data_source>wl_data_source</a></h2><p class=summary>offer to transfer data</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_data_source>wl_data_source</a></b> object is the source side of a <b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b>.
It is created by the source client in a data transfer and
provides a way to describe the offered data and a way to respond
to requests to transfer the data.</div><div class=message-head><div class=row><div><h3><a id=wl_data_source.offer href=#wl_data_source.offer>wl_data_source.offer</a></h3><p class=summary>add an offered mime type</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request adds a mime type to the set of mime types
advertised to targets. Can be called several times to offer
multiple types.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>mime_type<td>string<td><p>mime type offered by the data source</table><div class=message-head><div class=row><div><h3><a id=wl_data_source.destroy href=#wl_data_source.destroy>wl_data_source.destroy</a></h3><p class=summary>destroy the data source</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Destroy the data source.</div><div class=message-head><div class=row><div><h3><a id=wl_data_source.set_actions href=#wl_data_source.set_actions>wl_data_source.set_actions</a></h3><p class=summary>set the available drag-and-drop actions</div><div><b>Request</b><br>Since Version 3</div></div></div><div class=description><p>Sets the actions that the source side client supports for this
operation. This request may trigger <b><a href=/docs/wayland/wayland/#wl_data_source.action>wl_data_source.action</a></b> and
<b><a href=/docs/wayland/wayland/#wl_data_offer.action>wl_data_offer.action</a></b> events if the compositor needs to change the
selected action.<p>The dnd_actions argument must contain only values expressed in the
<b><a href=/docs/wayland/wayland/#></a></b>enum, otherwise it will result
in a protocol error.<p>This request must be made once only, and can only be made on sources
used in drag-and-drop, so it must be performed before
<b><a href=/docs/wayland/wayland/#wl_data_device.start_drag>wl_data_device.start_drag</a></b>. Attempting to use the source other than
for drag-and-drop will raise a protocol error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>dnd_actions<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></b>><td><p>actions supported by the data source</table><div class=message-head><div class=row><div><h3><a id=wl_data_source.target href=#wl_data_source.target>wl_data_source.target</a></h3><p class=summary>a target accepts an offered mime type</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Sent when a target accepts pointer_focus or motion events. If
a target does not accept any of the offered types, type is NULL.<p>Used for feedback during drag-and-drop.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>mime_type<td>nullable
string<td><p>mime type accepted by the target</table><div class=message-head><div class=row><div><h3><a id=wl_data_source.send href=#wl_data_source.send>wl_data_source.send</a></h3><p class=summary>send the data</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Request for data from the client. Send the data as the
specified mime type over the passed file descriptor, then
close it.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>mime_type<td>string<td><p>mime type for the data<tr><td>fd<td>fd<td><p>file descriptor for the data</table><div class=message-head><div class=row><div><h3><a id=wl_data_source.cancelled href=#wl_data_source.cancelled>wl_data_source.cancelled</a></h3><p class=summary>selection was cancelled</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This data source is no longer valid. There are several reasons why
this could happen:<p>- The data source has been replaced by another data source.
- The drag-and-drop operation was performed, but the drop destination
did not accept any of the mime types offered through
<b><a href=/docs/wayland/wayland/#wl_data_source.target>wl_data_source.target</a></b>.
- The drag-and-drop operation was performed, but the drop destination
did not select any of the actions present in the mask offered through
<b><a href=/docs/wayland/wayland/#wl_data_source.action>wl_data_source.action</a></b>.
- The drag-and-drop operation was performed but didn't happen over a
surface.
- The compositor cancelled the drag-and-drop operation (e.g. compositor
dependent timeouts to avoid stale drag-and-drop transfers).<p>The client should clean up and destroy this data source.<p>For objects of version 2 or older, <b><a href=/docs/wayland/wayland/#wl_data_source.cancelled>wl_data_source.cancelled</a></b> will
only be emitted if the data source was replaced by another data
source.</div><div class=message-head><div class=row><div><h3><a id=wl_data_source.dnd_drop_performed href=#wl_data_source.dnd_drop_performed>wl_data_source.dnd_drop_performed</a></h3><p class=summary>the drag-and-drop operation physically finished</div><div><b>Event</b><br>Since Version 3</div></div></div><div class=description><p>The user performed the drop action. This event does not indicate
acceptance, <b><a href=/docs/wayland/wayland/#wl_data_source.cancelled>wl_data_source.cancelled</a></b> may still be emitted afterwards
if the drop destination does not accept any mime type.<p>However, this event might however not be received if the compositor
cancelled the drag-and-drop operation before this event could happen.<p>Note that the data_source may still be used in the future and should
not be destroyed here.</div><div class=message-head><div class=row><div><h3><a id=wl_data_source.dnd_finished href=#wl_data_source.dnd_finished>wl_data_source.dnd_finished</a></h3><p class=summary>the drag-and-drop operation concluded</div><div><b>Event</b><br>Since Version 3</div></div></div><div class=description><p>The drop destination finished interoperating with this data
source, so the client is now free to destroy this data source and
free all associated data.<p>If the action used to perform the operation was "move", the
source can now delete the transferred data.</div><div class=message-head><div class=row><div><h3><a id=wl_data_source.action href=#wl_data_source.action>wl_data_source.action</a></h3><p class=summary>notify the selected action</div><div><b>Event</b><br>Since Version 3</div></div></div><div class=description><p>This event indicates the action selected by the compositor after
matching the source/destination side actions. Only one action (or
none) will be offered here.<p>This event can be emitted multiple times during the drag-and-drop
operation, mainly in response to destination side changes through
<b><a href=/docs/wayland/wayland/#wl_data_offer.set_actions>wl_data_offer.set_actions</a></b>, and as the data device enters/leaves
surfaces.<p>It is only possible to receive this event after
<b><a href=/docs/wayland/wayland/#wl_data_source.dnd_drop_performed>wl_data_source.dnd_drop_performed</a></b> if the drag-and-drop operation
ended in an "ask" action, in which case the final <b><a href=/docs/wayland/wayland/#wl_data_source.action>wl_data_source.action</a></b>
event will happen immediately before <b><a href=/docs/wayland/wayland/#wl_data_source.dnd_finished>wl_data_source.dnd_finished</a></b>.<p>Compositors may also change the selected action on the fly, mainly
in response to keyboard modifier changes during the drag-and-drop
operation.<p>The most recent action received is always the valid one. The chosen
action may change alongside negotiation (e.g. an "ask" action can turn
into a "move" operation), so the effects of the final action must
always be applied in <b><a href=/docs/wayland/wayland/#></a></b>.<p>Clients can trigger cursor surface changes from this point, so
they reflect the current action.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>dnd_action<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></b>><td><p>action selected by the compositor</table><div class=message-head><div class=row><div><h3><a id=wl_data_source.enums.error href=#wl_data_source.enums.error>wl_data_source.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>invalid_action_mask<td>0<td>1<td><p>action mask contains invalid values<tr><td>invalid_source<td>1<td>1<td><p>source doesn't accept this request</table><div class=interface-head><div class=row><div><h2><a id=wl_data_device href=#wl_data_device>wl_data_device</a></h2><p class=summary>data transfer device</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>There is one <b><a href=/docs/wayland/wayland/#wl_data_device>wl_data_device</a></b> per seat which can be obtained
from the global <b><a href=/docs/wayland/wayland/#wl_data_device_manager>wl_data_device_manager</a></b> singleton.<p>A <b><a href=/docs/wayland/wayland/#wl_data_device>wl_data_device</a></b> provides access to inter-client data transfer
mechanisms such as copy-and-paste and drag-and-drop.</div><div class=message-head><div class=row><div><h3><a id=wl_data_device.start_drag href=#wl_data_device.start_drag>wl_data_device.start_drag</a></h3><p class=summary>start drag-and-drop operation</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request asks the compositor to start a drag-and-drop
operation on behalf of the client.<p>The source argument is the data source that provides the data
for the eventual data transfer. If source is NULL, enter, leave
and motion events are sent only to the client that initiated the
drag and the client is expected to handle the data passing
internally. If source is destroyed, the drag-and-drop session will be
cancelled.<p>The origin surface is the surface where the drag originates and
the client must have an active implicit grab that matches the
serial.<p>The icon surface is an optional (can be NULL) surface that
provides an icon to be moved around with the cursor. Initially,
the top-left corner of the icon surface is placed at the cursor
hotspot, but subsequent <b><a href=/docs/wayland/wayland/#wl_surface.offset>wl_surface.offset</a></b> requests can move the
relative position. Attach requests must be confirmed with
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> as usual. The icon surface is given the role of
a drag-and-drop icon. If the icon surface already has another role,
it raises a protocol error.<p>The input region is ignored for wl_surfaces with the role of a
drag-and-drop icon.<p>The given source may not be used in any further set_selection or
start_drag requests. Attempting to reuse a previously-used source
may send a used_source error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>source<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_data_source>wl_data_source</a></b>><td><p>data source for the eventual transfer<tr><td>origin<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface where the drag originates<tr><td>icon<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>drag-and-drop icon surface<tr><td>serial<td>uint<td><p>serial number of the implicit grab on the origin</table><div class=message-head><div class=row><div><h3><a id=wl_data_device.set_selection href=#wl_data_device.set_selection>wl_data_device.set_selection</a></h3><p class=summary>copy data to the selection</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request asks the compositor to set the selection
to the data from the source on behalf of the client.<p>To unset the selection, set the source to NULL.<p>The given source may not be used in any further set_selection or
start_drag requests. Attempting to reuse a previously-used source
may send a used_source error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>source<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_data_source>wl_data_source</a></b>><td><p>data source for the selection<tr><td>serial<td>uint<td><p>serial number of the event that triggered this request</table><div class=message-head><div class=row><div><h3><a id=wl_data_device.release href=#wl_data_device.release>wl_data_device.release</a></h3><p class=summary>destroy data device</div><div><b>Destructor
Request</b><br>Since Version 2</div></div></div><div class=description><p>This request destroys the data device.</div><div class=message-head><div class=row><div><h3><a id=wl_data_device.data_offer href=#wl_data_device.data_offer>wl_data_device.data_offer</a></h3><p class=summary>introduce a new wl_data_offer</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The data_offer event introduces a new <b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b> object,
which will subsequently be used in either the
data_device.enter event (for drag-and-drop) or the
data_device.selection event (for selections). Immediately
following the data_device.data_offer event, the new data_offer
object will send out data_offer.offer events to describe the
mime types it offers.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b>><td><p>the new data_offer object</table><div class=message-head><div class=row><div><h3><a id=wl_data_device.enter href=#wl_data_device.enter>wl_data_device.enter</a></h3><p class=summary>initiate drag-and-drop session</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event is sent when an active drag-and-drop pointer enters
a surface owned by the client. The position of the pointer at
enter time is provided by the x and y arguments, in surface-local
coordinates.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the enter event<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>client surface entered<tr><td>x<td>fixed<td><p>surface-local x coordinate<tr><td>y<td>fixed<td><p>surface-local y coordinate<tr><td>id<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b>><td><p>source data_offer object</table><div class=message-head><div class=row><div><h3><a id=wl_data_device.leave href=#wl_data_device.leave>wl_data_device.leave</a></h3><p class=summary>end drag-and-drop session</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event is sent when the drag-and-drop pointer leaves the
surface and the session ends. The client must destroy the
<b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b> introduced at enter time at this point.</div><div class=message-head><div class=row><div><h3><a id=wl_data_device.motion href=#wl_data_device.motion>wl_data_device.motion</a></h3><p class=summary>drag-and-drop session motion</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event is sent when the drag-and-drop pointer moves within
the currently focused surface. The new position of the pointer
is provided by the x and y arguments, in surface-local
coordinates.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>x<td>fixed<td><p>surface-local x coordinate<tr><td>y<td>fixed<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_data_device.drop href=#wl_data_device.drop>wl_data_device.drop</a></h3><p class=summary>end drag-and-drop session successfully</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The event is sent when a drag-and-drop operation is ended
because the implicit grab is removed.<p>The drag-and-drop destination is expected to honor the last action
received through <b><a href=/docs/wayland/wayland/#wl_data_offer.action>wl_data_offer.action</a></b>, if the resulting action is
"copy" or "move", the destination can still perform
<b><a href=/docs/wayland/wayland/#wl_data_offer.receive>wl_data_offer.receive</a></b> requests, and is expected to end all
transfers with a <b><a href=/docs/wayland/wayland/#wl_data_offer.finish>wl_data_offer.finish</a></b> request.<p>If the resulting action is "ask", the action will not be considered
final. The drag-and-drop destination is expected to perform one last
<b><a href=/docs/wayland/wayland/#wl_data_offer.set_actions>wl_data_offer.set_actions</a></b> request, or <b><a href=/docs/wayland/wayland/#wl_data_offer.destroy>wl_data_offer.destroy</a></b> in order
to cancel the operation.</div><div class=message-head><div class=row><div><h3><a id=wl_data_device.selection href=#wl_data_device.selection>wl_data_device.selection</a></h3><p class=summary>advertise new selection</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The selection event is sent out to notify the client of a new
<b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b> for the selection for this device. The
data_device.data_offer and the data_offer.offer events are
sent out immediately before this event to introduce the data
offer object. The selection event is sent to a client
immediately before receiving keyboard focus and when a new
selection is set while the client has keyboard focus. The
data_offer is valid until a new data_offer or NULL is received
or until the client loses keyboard focus. Switching surface with
keyboard focus within the same client doesn't mean a new selection
will be sent. The client must destroy the previous selection
data_offer, if any, upon receiving this event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_data_offer>wl_data_offer</a></b>><td><p>selection data_offer object</table><div class=message-head><div class=row><div><h3><a id=wl_data_device.enums.error href=#wl_data_device.enums.error>wl_data_device.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>role<td>0<td>1<td><p>given wl_surface has another role<tr><td>used_source<td>1<td>1<td><p>source has already been used</table><div class=interface-head><div class=row><div><h2><a id=wl_data_device_manager href=#wl_data_device_manager>wl_data_device_manager</a></h2><p class=summary>data transfer interface</div><div><b>Interface</b><br>Version 3</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_data_device_manager>wl_data_device_manager</a></b> is a singleton global object that
provides access to inter-client data transfer mechanisms such as
copy-and-paste and drag-and-drop. These mechanisms are tied to
a <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> and this interface lets a client get a <b><a href=/docs/wayland/wayland/#wl_data_device>wl_data_device</a></b>
corresponding to a <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b>.<p>Depending on the version bound, the objects created from the bound
<b><a href=/docs/wayland/wayland/#wl_data_device_manager>wl_data_device_manager</a></b> object will have different requirements for
functioning properly. See <b><a href=/docs/wayland/wayland/#wl_data_source.set_actions>wl_data_source.set_actions</a></b>,
<b><a href=/docs/wayland/wayland/#wl_data_offer.accept>wl_data_offer.accept</a></b> and <b><a href=/docs/wayland/wayland/#wl_data_offer.finish>wl_data_offer.finish</a></b> for details.</div><div class=message-head><div class=row><div><h3><a id=wl_data_device_manager.create_data_source href=#wl_data_device_manager.create_data_source>wl_data_device_manager.create_data_source</a></h3><p class=summary>create a new data source</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a new data source.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_data_source>wl_data_source</a></b>><td><p>data source to create</table><div class=message-head><div class=row><div><h3><a id=wl_data_device_manager.get_data_device href=#wl_data_device_manager.get_data_device>wl_data_device_manager.get_data_device</a></h3><p class=summary>create a new data device</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a new data device for a given seat.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_data_device>wl_data_device</a></b>><td><p>data device to create<tr><td>seat<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b>><td><p>seat associated with the data device</table><div class=message-head><div class=row><div><h3><a id=wl_data_device_manager.enums.dnd_action href=#wl_data_device_manager.enums.dnd_action>wl_data_device_manager.dnd_action</a></h3><p class=summary>drag and drop actions</div><div><b>Bitfield
Enum</b><br>Since Version 3</div></div></div><div class=description><p>This is a bitmask of the available/preferred actions in a
drag-and-drop operation.<p>In the compositor, the selected action is a result of matching the
actions offered by the source and destination sides. "action" events
with a "none" action will be sent to both source and destination if
there is no match. All further checks will effectively happen on
(source actions  destination actions).<p>In addition, compositors may also pick different actions in
reaction to key modifiers being pressed. One common design that
is used in major toolkits (and the behavior recommended for
compositors) is:<p>- If no modifiers are pressed, the first match (in bit order)
will be used.
- Pressing Shift selects "move", if enabled in the mask.
- Pressing Control selects "copy", if enabled in the mask.<p>Behavior beyond that is considered implementation-dependent.
Compositors may for example bind other modifiers (like Alt/Meta)
or drags initiated with other buttons than BTN_LEFT to specific
actions (e.g. "ask").</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>none<td>0<td>1<td><p>no action<tr><td>copy<td>1<td>1<td><p>copy action<tr><td>move<td>2<td>1<td><p>move action<tr><td>ask<td>4<td>1<td><p>ask action</table><div class=interface-head><div class=row><div><h2><a id=wl_shell href=#wl_shell>wl_shell</a></h2><p class=summary>create desktop-style surfaces</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>This interface is implemented by servers that provide
desktop-style user interfaces.<p>It allows clients to associate a <b><a href=/docs/wayland/wayland/#wl_shell_surface>wl_shell_surface</a></b> with
a basic surface.<p>Note! This protocol is deprecated and not intended for production use.
For desktop-style user interfaces, use xdg_shell. Compositors and clients
should not implement this interface.</div><div class=message-head><div class=row><div><h3><a id=wl_shell.get_shell_surface href=#wl_shell.get_shell_surface>wl_shell.get_shell_surface</a></h3><p class=summary>create a shell surface from a surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a shell surface for an existing surface. This gives
the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> the role of a shell surface. If the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>
already has another role, it raises a protocol error.<p>Only one shell surface can be associated with a given surface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_shell_surface>wl_shell_surface</a></b>><td><p>shell surface to create<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface to be given the shell surface role</table><div class=message-head><div class=row><div><h3><a id=wl_shell.enums.error href=#wl_shell.enums.error>wl_shell.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>role<td>0<td>1<td><p>given wl_surface has another role</table><div class=interface-head><div class=row><div><h2><a id=wl_shell_surface href=#wl_shell_surface>wl_shell_surface</a></h2><p class=summary>desktop-style metadata interface</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>An interface that may be implemented by a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, for
implementations that provide a desktop-style user interface.<p>It provides requests to treat surfaces like toplevel, fullscreen
or popup windows, move, resize or maximize them, associate
metadata like title and class, etc.<p>On the server side the object is automatically destroyed when
the related <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> is destroyed. On the client side,
wl_shell_surface_destroy() must be called before destroying
the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> object.</div><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.pong href=#wl_shell_surface.pong>wl_shell_surface.pong</a></h3><p class=summary>respond to a ping event</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>A client must respond to a ping event with a pong request or
the client may be deemed unresponsive.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the ping event</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.move href=#wl_shell_surface.move>wl_shell_surface.move</a></h3><p class=summary>start an interactive move</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Start a pointer-driven move of the surface.<p>This request must be used in response to a button press event.
The server may ignore move requests depending on the state of
the surface (e.g. fullscreen or maximized).</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b>><td><p>seat whose pointer is used<tr><td>serial<td>uint<td><p>serial number of the implicit grab on the pointer</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.resize href=#wl_shell_surface.resize>wl_shell_surface.resize</a></h3><p class=summary>start an interactive resize</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Start a pointer-driven resizing of the surface.<p>This request must be used in response to a button press event.
The server may ignore resize requests depending on the state of
the surface (e.g. fullscreen or maximized).</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b>><td><p>seat whose pointer is used<tr><td>serial<td>uint<td><p>serial number of the implicit grab on the pointer<tr><td>edges<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shell_surface.enums.resize>resize</a></b>><td><p>which edge or corner is being dragged</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_toplevel href=#wl_shell_surface.set_toplevel>wl_shell_surface.set_toplevel</a></h3><p class=summary>make the surface a toplevel surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Map the surface as a toplevel surface.<p>A toplevel surface is not fullscreen, maximized or transient.</div><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_transient href=#wl_shell_surface.set_transient>wl_shell_surface.set_transient</a></h3><p class=summary>make the surface a transient surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Map the surface relative to an existing surface.<p>The x and y arguments specify the location of the upper left
corner of the surface relative to the upper left corner of the
parent surface, in surface-local coordinates.<p>The flags argument controls details of the transient behaviour.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>parent<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>parent surface<tr><td>x<td>int<td><p>surface-local x coordinate<tr><td>y<td>int<td><p>surface-local y coordinate<tr><td>flags<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shell_surface.enums.transient>transient</a></b>><td><p>transient surface behavior</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_fullscreen href=#wl_shell_surface.set_fullscreen>wl_shell_surface.set_fullscreen</a></h3><p class=summary>make the surface a fullscreen surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Map the surface as a fullscreen surface.<p>If an output parameter is given then the surface will be made
fullscreen on that output. If the client does not specify the
output then the compositor will apply its policy - usually
choosing the output on which the surface has the biggest surface
area.<p>The client may specify a method to resolve a size conflict
between the output size and the surface size - this is provided
through the method parameter.<p>The framerate parameter is used only when the method is set
to "driver", to indicate the preferred framerate. A value of 0
indicates that the client does not care about framerate. The
framerate is specified in mHz, that is framerate of 60000 is 60Hz.<p>A method of "scale" or "driver" implies a scaling operation of
the surface, either via a direct scaling operation or a change of
the output mode. This will override any kind of output scaling, so
that mapping a surface with a buffer size equal to the mode can
fill the screen independent of buffer_scale.<p>A method of "fill" means we don't scale up the buffer, however
any output scale is applied. This means that you may run into
an edge case where the application maps a buffer with the same
size of the output mode but buffer_scale 1 (thus making a
surface larger than the output). In this case it is allowed to
downscale the results to fit the screen.<p>The compositor must reply to this request with a configure event
with the dimensions for the output on which the surface will
be made fullscreen.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>method<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shell_surface.enums.fullscreen_method>fullscreen_method</a></b>><td><p>method for resolving size conflict<tr><td>framerate<td>uint<td><p>framerate in mHz<tr><td>output<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b>><td><p>output on which the surface is to be fullscreen</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_popup href=#wl_shell_surface.set_popup>wl_shell_surface.set_popup</a></h3><p class=summary>make the surface a popup surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Map the surface as a popup.<p>A popup surface is a transient surface with an added pointer
grab.<p>An existing implicit grab will be changed to owner-events mode,
and the popup grab will continue after the implicit grab ends
(i.e. releasing the mouse button does not cause the popup to
be unmapped).<p>The popup grab continues until the window is destroyed or a
mouse button is pressed in any other client's window. A click
in any of the client's surfaces is reported as normal, however,
clicks in other clients' surfaces will be discarded and trigger
the callback.<p>The x and y arguments specify the location of the upper left
corner of the surface relative to the upper left corner of the
parent surface, in surface-local coordinates.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>seat<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b>><td><p>seat whose pointer is used<tr><td>serial<td>uint<td><p>serial number of the implicit grab on the pointer<tr><td>parent<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>parent surface<tr><td>x<td>int<td><p>surface-local x coordinate<tr><td>y<td>int<td><p>surface-local y coordinate<tr><td>flags<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shell_surface.enums.transient>transient</a></b>><td><p>transient surface behavior</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_maximized href=#wl_shell_surface.set_maximized>wl_shell_surface.set_maximized</a></h3><p class=summary>make the surface a maximized surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Map the surface as a maximized surface.<p>If an output parameter is given then the surface will be
maximized on that output. If the client does not specify the
output then the compositor will apply its policy - usually
choosing the output on which the surface has the biggest surface
area.<p>The compositor will reply with a configure event telling
the expected new surface size. The operation is completed
on the next buffer attach to this surface.<p>A maximized surface typically fills the entire output it is
bound to, except for desktop elements such as panels. This is
the main difference between a maximized shell surface and a
fullscreen shell surface.<p>The details depend on the compositor implementation.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>output<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b>><td><p>output on which the surface is to be maximized</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_title href=#wl_shell_surface.set_title>wl_shell_surface.set_title</a></h3><p class=summary>set surface title</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Set a short title for the surface.<p>This string may be used to identify the surface in a task bar,
window list, or other user interface elements provided by the
compositor.<p>The string must be encoded in UTF-8.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>title<td>string<td><p>surface title</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.set_class href=#wl_shell_surface.set_class>wl_shell_surface.set_class</a></h3><p class=summary>set surface class</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Set a class for the surface.<p>The surface class identifies the general class of applications
to which the surface belongs. A common convention is to use the
file name (or the full path if it is a non-standard location) of
the application's .desktop file as the class.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>class_<td>string<td><p>surface class</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.ping href=#wl_shell_surface.ping>wl_shell_surface.ping</a></h3><p class=summary>ping client</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Ping a client to check if it is receiving events and sending
requests. A client is expected to reply with a pong request.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the ping</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.configure href=#wl_shell_surface.configure>wl_shell_surface.configure</a></h3><p class=summary>suggest resize</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The configure event asks the client to resize its surface.<p>The size is a hint, in the sense that the client is free to
ignore it if it doesn't resize, pick a smaller size (to
satisfy aspect ratio or resize in steps of NxM pixels).<p>The edges parameter provides a hint about how the surface
was resized. The client may use this information to decide
how to adjust its content to the new size (e.g. a scrolling
area might adjust its content position to leave the viewable
content unmoved).<p>The client is free to dismiss all but the last configure
event it received.<p>The width and height arguments specify the size of the window
in surface-local coordinates.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>edges<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_shell_surface.enums.resize>resize</a></b>><td><p>how the surface was resized<tr><td>width<td>int<td><p>new width of the surface<tr><td>height<td>int<td><p>new height of the surface</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.popup_done href=#wl_shell_surface.popup_done>wl_shell_surface.popup_done</a></h3><p class=summary>popup interaction is done</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The popup_done event is sent out when a popup grab is broken,
that is, when the user clicks a surface that doesn't belong
to the client owning the popup surface.</div><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.enums.resize href=#wl_shell_surface.enums.resize>wl_shell_surface.resize</a></h3><p class=summary>edge values for resizing</div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><div class=description><p>These values are used to indicate which edge of a surface
is being dragged in a resize operation. The server may
use this information to adapt its behavior, e.g. choose
an appropriate cursor image.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>none<td>0<td>1<td><p>no edge<tr><td>top<td>1<td>1<td><p>top edge<tr><td>bottom<td>2<td>1<td><p>bottom edge<tr><td>left<td>4<td>1<td><p>left edge<tr><td>top_left<td>5<td>1<td><p>top and left edges<tr><td>bottom_left<td>6<td>1<td><p>bottom and left edges<tr><td>right<td>8<td>1<td><p>right edge<tr><td>top_right<td>9<td>1<td><p>top and right edges<tr><td>bottom_right<td>10<td>1<td><p>bottom and right edges</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.enums.transient href=#wl_shell_surface.enums.transient>wl_shell_surface.transient</a></h3><p class=summary>details of transient behaviour</div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><div class=description><p>These flags specify details of the expected behaviour
of transient surfaces. Used in the set_transient request.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>inactive<td>0x1<td>1<td><p>do not set keyboard focus</table><div class=message-head><div class=row><div><h3><a id=wl_shell_surface.enums.fullscreen_method href=#wl_shell_surface.enums.fullscreen_method>wl_shell_surface.fullscreen_method</a></h3><p class=summary>different method to set the surface fullscreen</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>Hints to indicate to the compositor how to deal with a conflict
between the dimensions of the surface and the dimensions of the
output. The compositor is free to ignore this parameter.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>default<td>0<td>1<td><p>no preference, apply default policy<tr><td>scale<td>1<td>1<td><p>scale, preserve the surface's aspect ratio and center on output<tr><td>driver<td>2<td>1<td><p>switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch<tr><td>fill<td>3<td>1<td><p>no upscaling, center on output and add black borders to compensate size mismatch</table><div class=interface-head><div class=row><div><h2><a id=wl_surface href=#wl_surface>wl_surface</a></h2><p class=summary>an onscreen surface</div><div><b>Interface</b><br>Version 6</div></div></div><div class=description><p>A surface is a rectangular area that may be displayed on zero
or more outputs, and shown any number of times at the compositor's
discretion. They can present wl_buffers, receive user input, and
define a local coordinate system.<p>The size of a surface (and relative positions on it) is described
in surface-local coordinates, which may differ from the buffer
coordinates of the pixel content, in case a buffer_transform
or a buffer_scale is used.<p>A surface without a "role" is fairly useless: a compositor does
not know where, when or how to present it. The role is the
purpose of a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>. Examples of roles are a cursor for a
pointer (as set by <b><a href=/docs/wayland/wayland/#wl_pointer.set_cursor>wl_pointer.set_cursor</a></b>), a drag icon
(<b><a href=/docs/wayland/wayland/#wl_data_device.start_drag>wl_data_device.start_drag</a></b>), a sub-surface
(<b><a href=/docs/wayland/wayland/#wl_subcompositor.get_subsurface>wl_subcompositor.get_subsurface</a></b>), and a window as defined by a
shell protocol (e.g. <b><a href=/docs/wayland/wayland/#wl_shell.get_shell_surface>wl_shell.get_shell_surface</a></b>).<p>A surface can have only one role at a time. Initially a
<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> does not have a role. Once a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> is given a
role, it is set permanently for the whole lifetime of the
<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> object. Giving the current role again is allowed,
unless explicitly forbidden by the relevant interface
specification.<p>Surface roles are given by requests in other interfaces such as
<b><a href=/docs/wayland/wayland/#wl_pointer.set_cursor>wl_pointer.set_cursor</a></b>. The request should explicitly mention
that this request gives a role to a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>. Often, this
request also creates a new protocol object that represents the
role and adds additional functionality to <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>. When a
client wants to destroy a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, they must destroy this role
object before the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, otherwise a defunct_role_object error is
sent.<p>Destroying the role object does not remove the role from the
<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, but it may stop the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> from "playing the role".
For instance, if a <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> object is destroyed, the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>
it was created for will be unmapped and forget its position and
z-order. It is allowed to create a <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> for the same
<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> again, but it is not allowed to use the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> as
a cursor (cursor is a different role than sub-surface, and role
switching is not allowed).</div><div class=message-head><div class=row><div><h3><a id=wl_surface.destroy href=#wl_surface.destroy>wl_surface.destroy</a></h3><p class=summary>delete surface</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Deletes the surface and invalidates its object ID.</div><div class=message-head><div class=row><div><h3><a id=wl_surface.attach href=#wl_surface.attach>wl_surface.attach</a></h3><p class=summary>set the surface contents</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Set a buffer as the content of this surface.<p>The new size of the surface is calculated based on the buffer
size transformed by the inverse buffer_transform and the
inverse buffer_scale. This means that at commit time the supplied
buffer size must be an integer multiple of the buffer_scale. If
that's not the case, an invalid_size error is sent.<p>The x and y arguments specify the location of the new pending
buffer's upper left corner, relative to the current buffer's upper
left corner, in surface-local coordinates. In other words, the
x and y, combined with the new surface size define in which
directions the surface's size changes. Setting anything other than 0
as x and y arguments is discouraged, and should instead be replaced
with using the separate <b><a href=/docs/wayland/wayland/#wl_surface.offset>wl_surface.offset</a></b> request.<p>When the bound <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> version is 5 or higher, passing any
non-zero x or y is a protocol violation, and will result in an
'invalid_offset' error being raised. The x and y arguments are ignored
and do not change the pending state. To achieve equivalent semantics,
use <b><a href=/docs/wayland/wayland/#wl_surface.offset>wl_surface.offset</a></b>.<p>Surface contents are double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p>The initial surface contents are void; there is no content.
<b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b> assigns the given <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> as the pending
<b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>. <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> makes the pending <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> the new
surface contents, and the size of the surface becomes the size
calculated from the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>, as described above. After commit,
there is no pending buffer until the next attach.<p>Committing a pending <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> allows the compositor to read the
pixels in the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>. The compositor may access the pixels at
any time after the <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> request. When the compositor
will not access the pixels anymore, it will send the
<b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b> event. Only after receiving <b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b>,
the client may reuse the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>. A <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> that has been
attached and then replaced by another attach instead of committed
will not receive a release event, and is not used by the
compositor.<p>If a pending <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> has been committed to more than one <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>,
the delivery of <b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b> events becomes undefined. A well
behaved client should not rely on <b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b> events in this
case. Alternatively, a client could create multiple <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> objects
from the same backing storage or use a protocol extension providing
per-commit release notifications.<p>Destroying the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> after <b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b> does not change
the surface contents. Destroying the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> before <b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b>
is allowed as long as the underlying buffer storage isn't re-used (this
can happen e.g. on client process termination). However, if the client
destroys the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> before receiving the <b><a href=/docs/wayland/wayland/#wl_buffer.release>wl_buffer.release</a></b> event and
mutates the underlying buffer storage, the surface contents become
undefined immediately.<p>If <b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b> is sent with a NULL <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>, the
following <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> will remove the surface content.<p>If a pending <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> has been destroyed, the result is not specified.
Many compositors are known to remove the surface content on the following
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>, but this behaviour is not universal. Clients seeking to
maximise compatibility should not destroy pending buffers and should
ensure that they explicitly remove content from surfaces, even after
destroying buffers.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>buffer<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>><td><p>buffer of surface contents<tr><td>x<td>int<td><p>surface-local x coordinate<tr><td>y<td>int<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_surface.damage href=#wl_surface.damage>wl_surface.damage</a></h3><p class=summary>mark part of the surface damaged</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request is used to describe the regions where the pending
buffer is different from the current surface contents, and where
the surface therefore needs to be repainted. The compositor
ignores the parts of the damage that fall outside of the surface.<p>Damage is double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p>The damage rectangle is specified in surface-local coordinates,
where x and y specify the upper left corner of the damage rectangle.<p>The initial value for pending damage is empty: no damage.
<b><a href=/docs/wayland/wayland/#wl_surface.damage>wl_surface.damage</a></b> adds pending damage: the new pending damage
is the union of old pending damage and the given rectangle.<p><b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> assigns pending damage as the current damage,
and clears pending damage. The server will clear the current
damage as it repaints the surface.<p>Note! New clients should not use this request. Instead damage can be
posted with <b><a href=/docs/wayland/wayland/#wl_surface.damage_buffer>wl_surface.damage_buffer</a></b> which uses buffer coordinates
instead of surface coordinates.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>surface-local x coordinate<tr><td>y<td>int<td><p>surface-local y coordinate<tr><td>width<td>int<td><p>width of damage rectangle<tr><td>height<td>int<td><p>height of damage rectangle</table><div class=message-head><div class=row><div><h3><a id=wl_surface.frame href=#wl_surface.frame>wl_surface.frame</a></h3><p class=summary>request a frame throttling hint</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Request a notification when it is a good time to start drawing a new
frame, by creating a frame callback. This is useful for throttling
redrawing operations, and driving animations.<p>When a client is animating on a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, it can use the 'frame'
request to get notified when it is a good time to draw and commit the
next frame of animation. If the client commits an update earlier than
that, it is likely that some updates will not make it to the display,
and the client is wasting resources by drawing too often.<p>The frame request will take effect on the next <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.
The notification will only be posted for one frame unless
requested again. For a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, the notifications are posted in
the order the frame requests were committed.<p>The server must send the notifications so that a client
will not send excessive updates, while still allowing
the highest possible update rate for clients that wait for the reply
before drawing again. The server should give some time for the client
to draw and commit after sending the frame callback events to let it
hit the next output refresh.<p>A server should avoid signaling the frame callbacks if the
surface is not visible in any way, e.g. the surface is off-screen,
or completely obscured by other opaque surfaces.<p>The object returned by this request will be destroyed by the
compositor after the callback is fired and as such the client must not
attempt to use it after that point.<p>The callback_data passed in the callback is the current time, in
milliseconds, with an undefined base.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>callback<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_callback>wl_callback</a></b>><td><p>callback object for the frame request</table><div class=message-head><div class=row><div><h3><a id=wl_surface.set_opaque_region href=#wl_surface.set_opaque_region>wl_surface.set_opaque_region</a></h3><p class=summary>set opaque region</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request sets the region of the surface that contains
opaque content.<p>The opaque region is an optimization hint for the compositor
that lets it optimize the redrawing of content behind opaque
regions. Setting an opaque region is not required for correct
behaviour, but marking transparent content as opaque will result
in repaint artifacts.<p>The opaque region is specified in surface-local coordinates.<p>The compositor ignores the parts of the opaque region that fall
outside of the surface.<p>Opaque region is double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p><b><a href=/docs/wayland/wayland/#wl_surface.set_opaque_region>wl_surface.set_opaque_region</a></b> changes the pending opaque region.
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> copies the pending region to the current region.
Otherwise, the pending and current regions are never changed.<p>The initial value for an opaque region is empty. Setting the pending
opaque region has copy semantics, and the <b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b> object can be
destroyed immediately. A NULL <b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b> causes the pending opaque
region to be set to empty.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>region<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b>><td><p>opaque region of the surface</table><div class=message-head><div class=row><div><h3><a id=wl_surface.set_input_region href=#wl_surface.set_input_region>wl_surface.set_input_region</a></h3><p class=summary>set input region</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request sets the region of the surface that can receive
pointer and touch events.<p>Input events happening outside of this region will try the next
surface in the server surface stack. The compositor ignores the
parts of the input region that fall outside of the surface.<p>The input region is specified in surface-local coordinates.<p>Input region is double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p><b><a href=/docs/wayland/wayland/#wl_surface.set_input_region>wl_surface.set_input_region</a></b> changes the pending input region.
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> copies the pending region to the current region.
Otherwise the pending and current regions are never changed,
except cursor and icon surfaces are special cases, see
<b><a href=/docs/wayland/wayland/#wl_pointer.set_cursor>wl_pointer.set_cursor</a></b> and <b><a href=/docs/wayland/wayland/#wl_data_device.start_drag>wl_data_device.start_drag</a></b>.<p>The initial value for an input region is infinite. That means the
whole surface will accept input. Setting the pending input region
has copy semantics, and the <b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b> object can be destroyed
immediately. A NULL <b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b> causes the input region to be set
to infinite.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>region<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_region>wl_region</a></b>><td><p>input region of the surface</table><div class=message-head><div class=row><div><h3><a id=wl_surface.commit href=#wl_surface.commit>wl_surface.commit</a></h3><p class=summary>commit pending surface state</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Surface state (input, opaque, and damage regions, attached buffers,
etc.) is double-buffered. Protocol requests modify the pending state,
as opposed to the active state in use by the compositor.<p>All requests that need a commit to become effective are documented
to affect double-buffered state.<p>Other interfaces may add further double-buffered surface state.<p>A commit request atomically creates a Content Update (CU) from the
pending state, even if the pending state has not been touched. The
content update is placed at the end of a per-surface queue until it
becomes active. After commit, the new pending state is as documented for
each related request.<p>A CU is either a Desync Content Update (DCU) or a Sync Content Update
(SCU). If the surface is effectively synchronized at the commit request,
it is a SCU, otherwise a DCU.<p>When a surface transitions from effectively synchronized to effectively
desynchronized, all SCUs in its queue which are not reachable by any
DCU become DCUs and dependency edges from outside the queue to these CUs
are removed.<p>See <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> for the definition of 'effectively synchronized' and
'effectively desynchronized'.<p>When a CU is placed in the queue, the CU has a dependency on the CU in
front of it and to the SCU at end of the queue of every direct child
surface if that SCU exists and does not have another dependent. This can
form a directed acyclic graph of CUs with dependencies as edges.<p>In addition to surface state, the CU can have constraints that must be
satisfied before it can be applied. Other interfaces may add CU
constraints.<p>All DCUs which do not have a SCU in front of themselves in their queue,
are candidates. If the graph that's reachable by a candidate does not
have any unsatisfied constraints, the entire graph must be applied
atomically.<p>When a CU is applied, the <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> is applied before all other state.
This means that all coordinates in double-buffered state are relative to
the newly attached wl_buffers, except for <b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b> itself. If
there is no newly attached <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>, the coordinates are relative to
the previous content update.</div><div class=message-head><div class=row><div><h3><a id=wl_surface.set_buffer_transform href=#wl_surface.set_buffer_transform>wl_surface.set_buffer_transform</a></h3><p class=summary>sets the buffer transformation</div><div><b>Request</b><br>Since Version 2</div></div></div><div class=description><p>This request sets the transformation that the client has already applied
to the content of the buffer. The accepted values for the transform
parameter are the values for <b><a href=/docs/wayland/wayland/#wl_output.enums.transform>wl_output.enums.transform</a></b>.<p>The compositor applies the inverse of this transformation whenever it
uses the buffer contents.<p>Buffer transform is double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p>A newly created surface has its buffer transformation set to normal.<p><b><a href=/docs/wayland/wayland/#wl_surface.set_buffer_transform>wl_surface.set_buffer_transform</a></b> changes the pending buffer
transformation. <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> copies the pending buffer
transformation to the current one. Otherwise, the pending and current
values are never changed.<p>The purpose of this request is to allow clients to render content
according to the output transform, thus permitting the compositor to
use certain optimizations even if the display is rotated. Using
hardware overlays and scanning out a client buffer for fullscreen
surfaces are examples of such optimizations. Those optimizations are
highly dependent on the compositor implementation, so the use of this
request should be considered on a case-by-case basis.<p>Note that if the transform value includes 90 or 270 degree rotation,
the width of the buffer will become the surface height and the height
of the buffer will become the surface width.<p>If transform is not one of the values from the
<b><a href=/docs/wayland/wayland/#wl_output.enums.transform>wl_output.enums.transform</a></b> enum the invalid_transform protocol error
is raised.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>transform<td>int&lt;<b><a href=/docs/wayland/wayland/#wl_output.enums.transform>wl_output.transform</a></b>><td><p>transform for interpreting buffer contents</table><div class=message-head><div class=row><div><h3><a id=wl_surface.set_buffer_scale href=#wl_surface.set_buffer_scale>wl_surface.set_buffer_scale</a></h3><p class=summary>sets the buffer scaling factor</div><div><b>Request</b><br>Since Version 3</div></div></div><div class=description><p>This request sets an optional scaling factor on how the compositor
interprets the contents of the buffer attached to the window.<p>Buffer scale is double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p>A newly created surface has its buffer scale set to 1.<p><b><a href=/docs/wayland/wayland/#wl_surface.set_buffer_scale>wl_surface.set_buffer_scale</a></b> changes the pending buffer scale.
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> copies the pending buffer scale to the current one.
Otherwise, the pending and current values are never changed.<p>The purpose of this request is to allow clients to supply higher
resolution buffer data for use on high resolution outputs. It is
intended that you pick the same buffer scale as the scale of the
output that the surface is displayed on. This means the compositor
can avoid scaling when rendering the surface on that output.<p>Note that if the scale is larger than 1, then you have to attach
a buffer that is larger (by a factor of scale in each dimension)
than the desired surface size.<p>If scale is not greater than 0 the invalid_scale protocol error is
raised.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>scale<td>int<td><p>scale for interpreting buffer contents</table><div class=message-head><div class=row><div><h3><a id=wl_surface.damage_buffer href=#wl_surface.damage_buffer>wl_surface.damage_buffer</a></h3><p class=summary>mark part of the surface damaged using buffer coordinates</div><div><b>Request</b><br>Since Version 4</div></div></div><div class=description><p>This request is used to describe the regions where the pending
buffer is different from the current surface contents, and where
the surface therefore needs to be repainted. The compositor
ignores the parts of the damage that fall outside of the surface.<p>Damage is double-buffered state, see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p>The damage rectangle is specified in buffer coordinates,
where x and y specify the upper left corner of the damage rectangle.<p>The initial value for pending damage is empty: no damage.
<b><a href=/docs/wayland/wayland/#wl_surface.damage_buffer>wl_surface.damage_buffer</a></b> adds pending damage: the new pending
damage is the union of old pending damage and the given rectangle.<p><b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> assigns pending damage as the current damage,
and clears pending damage. The server will clear the current
damage as it repaints the surface.<p>This request differs from <b><a href=/docs/wayland/wayland/#wl_surface.damage>wl_surface.damage</a></b> in only one way - it
takes damage in buffer coordinates instead of surface-local
coordinates. While this generally is more intuitive than surface
coordinates, it is especially desirable when using <b><a href=/docs/wayland/viewporter/#wp_viewport>wp_viewport</a></b>
or when a drawing library (like EGL) is unaware of buffer scale
and buffer transform.<p>Note: Because buffer transformation changes and damage requests may
be interleaved in the protocol stream, it is impossible to determine
the actual mapping between surface and buffer damage until
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> time. Therefore, compositors wishing to take both
kinds of damage into account will have to accumulate damage from the
two requests separately and only transform from one to the other
after receiving the <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>buffer-local x coordinate<tr><td>y<td>int<td><p>buffer-local y coordinate<tr><td>width<td>int<td><p>width of damage rectangle<tr><td>height<td>int<td><p>height of damage rectangle</table><div class=message-head><div class=row><div><h3><a id=wl_surface.offset href=#wl_surface.offset>wl_surface.offset</a></h3><p class=summary>set the surface contents offset</div><div><b>Request</b><br>Since Version 5</div></div></div><div class=description><p>The x and y arguments specify the location of the new pending
buffer's upper left corner, relative to the current buffer's upper
left corner, in surface-local coordinates. In other words, the
x and y, combined with the new surface size define in which
directions the surface's size changes.<p>The exact semantics of <b><a href=/docs/wayland/wayland/#wl_surface.offset>wl_surface.offset</a></b> are role-specific. Refer to
the documentation of specific roles for more information.<p>Surface location offset is double-buffered state, see
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>.<p>This request is semantically equivalent to and the replaces the x and y
arguments in the <b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b> request in <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> versions prior
to 5. See <b><a href=/docs/wayland/wayland/#wl_surface.attach>wl_surface.attach</a></b> for details.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>surface-local x coordinate<tr><td>y<td>int<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_surface.enter href=#wl_surface.enter>wl_surface.enter</a></h3><p class=summary>surface enters an output</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This is emitted whenever a surface's creation, movement, or resizing
results in some part of it being within the scanout region of an
output.<p>Note that a surface may be overlapping with zero or more outputs.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>output<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b>><td><p>output entered by the surface</table><div class=message-head><div class=row><div><h3><a id=wl_surface.leave href=#wl_surface.leave>wl_surface.leave</a></h3><p class=summary>surface leaves an output</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This is emitted whenever a surface's creation, movement, or resizing
results in it no longer having any part of it within the scanout region
of an output.<p>Clients should not use the number of outputs the surface is on for frame
throttling purposes. The surface might be hidden even if no leave event
has been sent, and the compositor might expect new surface content
updates even if no enter event has been sent. The frame event should be
used instead.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>output<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b>><td><p>output left by the surface</table><div class=message-head><div class=row><div><h3><a id=wl_surface.preferred_buffer_scale href=#wl_surface.preferred_buffer_scale>wl_surface.preferred_buffer_scale</a></h3><p class=summary>preferred buffer scale for the surface</div><div><b>Event</b><br>Since Version 6</div></div></div><div class=description><p>This event indicates the preferred buffer scale for this surface. It is
sent whenever the compositor's preference changes.<p>Before receiving this event the preferred buffer scale for this surface
is 1.<p>It is intended that scaling aware clients use this event to scale their
content and use <b><a href=/docs/wayland/wayland/#wl_surface.set_buffer_scale>wl_surface.set_buffer_scale</a></b> to indicate the scale they
have rendered with. This allows clients to supply a higher detail
buffer.<p>The compositor shall emit a scale value greater than 0.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>factor<td>int<td><p>preferred scaling factor</table><div class=message-head><div class=row><div><h3><a id=wl_surface.preferred_buffer_transform href=#wl_surface.preferred_buffer_transform>wl_surface.preferred_buffer_transform</a></h3><p class=summary>preferred buffer transform for the surface</div><div><b>Event</b><br>Since Version 6</div></div></div><div class=description><p>This event indicates the preferred buffer transform for this surface.
It is sent whenever the compositor's preference changes.<p>Before receiving this event the preferred buffer transform for this
surface is normal.<p>Applying this transformation to the surface buffer contents and using
<b><a href=/docs/wayland/wayland/#wl_surface.set_buffer_transform>wl_surface.set_buffer_transform</a></b> might allow the compositor to use the
surface buffer more efficiently.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>transform<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_output.enums.transform>wl_output.transform</a></b>><td><p>preferred transform</table><div class=message-head><div class=row><div><h3><a id=wl_surface.enums.error href=#wl_surface.enums.error>wl_surface.error</a></h3><p class=summary>wl_surface error values</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>These errors can be emitted in response to <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> requests.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>invalid_scale<td>0<td>1<td><p>buffer scale value is invalid<tr><td>invalid_transform<td>1<td>1<td><p>buffer transform value is invalid<tr><td>invalid_size<td>2<td>1<td><p>buffer size is invalid<tr><td>invalid_offset<td>3<td>1<td><p>buffer offset is invalid<tr><td>defunct_role_object<td>4<td>1<td><p>surface was destroyed before its role object</table><div class=interface-head><div class=row><div><h2><a id=wl_seat href=#wl_seat>wl_seat</a></h2><p class=summary>group of input devices</div><div><b>Interface</b><br>Version 10</div></div></div><div class=description><p>A seat is a group of keyboards, pointer and touch devices. This
object is published as a global during start up, or when such a
device is hot plugged. A seat typically has a pointer and
maintains a keyboard focus and a pointer focus.</div><div class=message-head><div class=row><div><h3><a id=wl_seat.get_pointer href=#wl_seat.get_pointer>wl_seat.get_pointer</a></h3><p class=summary>return pointer object</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>The ID provided will be initialized to the <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> interface
for this seat.<p>This request only takes effect if the seat has the pointer
capability, or has had the pointer capability in the past.
It is a protocol violation to issue this request on a seat that has
never had the pointer capability. The missing_capability error will
be sent in this case.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b>><td><p>seat pointer</table><div class=message-head><div class=row><div><h3><a id=wl_seat.get_keyboard href=#wl_seat.get_keyboard>wl_seat.get_keyboard</a></h3><p class=summary>return keyboard object</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>The ID provided will be initialized to the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> interface
for this seat.<p>This request only takes effect if the seat has the keyboard
capability, or has had the keyboard capability in the past.
It is a protocol violation to issue this request on a seat that has
never had the keyboard capability. The missing_capability error will
be sent in this case.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b>><td><p>seat keyboard</table><div class=message-head><div class=row><div><h3><a id=wl_seat.get_touch href=#wl_seat.get_touch>wl_seat.get_touch</a></h3><p class=summary>return touch object</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>The ID provided will be initialized to the <b><a href=/docs/wayland/wayland/#wl_touch>wl_touch</a></b> interface
for this seat.<p>This request only takes effect if the seat has the touch
capability, or has had the touch capability in the past.
It is a protocol violation to issue this request on a seat that has
never had the touch capability. The missing_capability error will
be sent in this case.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_touch>wl_touch</a></b>><td><p>seat touch interface</table><div class=message-head><div class=row><div><h3><a id=wl_seat.release href=#wl_seat.release>wl_seat.release</a></h3><p class=summary>release the seat object</div><div><b>Destructor
Request</b><br>Since Version 5</div></div></div><div class=description><p>Using this request a client can tell the server that it is not going to
use the seat object anymore.</div><div class=message-head><div class=row><div><h3><a id=wl_seat.capabilities href=#wl_seat.capabilities>wl_seat.capabilities</a></h3><p class=summary>seat capabilities changed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This is sent on binding to the seat global or whenever a seat gains
or loses the pointer, keyboard or touch capabilities.
The argument is a capability enum containing the complete set of
capabilities this seat has.<p>When the pointer capability is added, a client may create a
<b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> object using the <b><a href=/docs/wayland/wayland/#wl_seat.get_pointer>wl_seat.get_pointer</a></b> request. This object
will receive pointer events until the capability is removed in the
future.<p>When the pointer capability is removed, a client should destroy the
<b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> objects associated with the seat where the capability was
removed, using the <b><a href=/docs/wayland/wayland/#wl_pointer.release>wl_pointer.release</a></b> request. No further pointer
events will be received on these objects.<p>In some compositors, if a seat regains the pointer capability and a
client has a previously obtained <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> object of version 4 or
less, that object may start sending pointer events again. This
behavior is considered a misinterpretation of the intended behavior
and must not be relied upon by the client. <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> objects of
version 5 or later must not send events if created before the most
recent event notifying the client of an added pointer capability.<p>The above behavior also applies to <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> and <b><a href=/docs/wayland/wayland/#wl_touch>wl_touch</a></b> with the
keyboard and touch capabilities, respectively.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>capabilities<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_seat.enums.capability>capability</a></b>><td><p>capabilities of the seat</table><div class=message-head><div class=row><div><h3><a id=wl_seat.name href=#wl_seat.name>wl_seat.name</a></h3><p class=summary>unique identifier for this seat</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>In a multi-seat configuration the seat name can be used by clients to
help identify which physical devices the seat represents.<p>The seat name is a UTF-8 string with no convention defined for its
contents. Each name is unique among all <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> globals. The name is
only guaranteed to be unique for the current compositor instance.<p>The same seat names are used for all clients. Thus, the name can be
shared across processes to refer to a specific <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> global.<p>The name event is sent after binding to the seat global, and should be sent
before announcing capabilities. This event only sent once per seat object,
and the name does not change over the lifetime of the <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> global.<p>Compositors may re-use the same seat name if the <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> global is
destroyed and re-created later.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>string<td><p>seat identifier</table><div class=message-head><div class=row><div><h3><a id=wl_seat.enums.capability href=#wl_seat.enums.capability>wl_seat.capability</a></h3><p class=summary>seat capability bitmask</div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><div class=description><p>This is a bitmask of capabilities this seat has; if a member is
set, then it is present on the seat.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>pointer<td>1<td>1<td><p>the seat has pointer devices<tr><td>keyboard<td>2<td>1<td><p>the seat has one or more keyboards<tr><td>touch<td>4<td>1<td><p>the seat has touch devices</table><div class=message-head><div class=row><div><h3><a id=wl_seat.enums.error href=#wl_seat.enums.error>wl_seat.error</a></h3><p class=summary>wl_seat error values</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>These errors can be emitted in response to <b><a href=/docs/wayland/wayland/#wl_seat>wl_seat</a></b> requests.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>missing_capability<td>0<td>1<td><p>get_pointer, get_keyboard or get_touch called on seat without the matching capability</table><div class=interface-head><div class=row><div><h2><a id=wl_pointer href=#wl_pointer>wl_pointer</a></h2><p class=summary>pointer input device</div><div><b>Interface</b><br>Version 10</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> interface represents one or more input devices,
such as mice, which control the pointer location and pointer_focus
of a seat.<p>The <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> interface generates motion, enter and leave
events for the surfaces that the pointer is located over,
and button and axis events for button presses, button releases
and scrolling.</div><div class=message-head><div class=row><div><h3><a id=wl_pointer.set_cursor href=#wl_pointer.set_cursor>wl_pointer.set_cursor</a></h3><p class=summary>set the pointer surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Set the pointer surface, i.e., the surface that contains the
pointer image (cursor). This request gives the surface the role
of a cursor. If the surface already has another role, it raises
a protocol error.<p>The cursor actually changes only if the pointer
focus for this device is one of the requesting client's surfaces
or the surface parameter is the current pointer surface. If
there was a previous surface set with this request it is
replaced. If surface is NULL, the pointer image is hidden.<p>The parameters hotspot_x and hotspot_y define the position of
the pointer surface relative to the pointer location. Its
top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
where (x, y) are the coordinates of the pointer location, in
surface-local coordinates.<p>On <b><a href=/docs/wayland/wayland/#wl_surface.offset>wl_surface.offset</a></b> requests to the pointer surface, hotspot_x
and hotspot_y are decremented by the x and y parameters
passed to the request. The offset must be applied by
<b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> as usual.<p>The hotspot can also be updated by passing the currently set
pointer surface to this request with new values for hotspot_x
and hotspot_y.<p>The input region is ignored for wl_surfaces with the role of
a cursor. When the use as a cursor ends, the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> is
unmapped.<p>The serial parameter must match the latest <b><a href=/docs/wayland/wayland/#wl_pointer.enter>wl_pointer.enter</a></b>
serial number sent to the client. Otherwise the request will be
ignored.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the enter event<tr><td>surface<td>nullable
object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>pointer surface<tr><td>hotspot_x<td>int<td><p>surface-local x coordinate<tr><td>hotspot_y<td>int<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.release href=#wl_pointer.release>wl_pointer.release</a></h3><p class=summary>release the pointer object</div><div><b>Destructor
Request</b><br>Since Version 3</div></div></div><div class=description><p>Using this request a client can tell the server that it is not going to
use the pointer object anymore.<p>This request destroys the pointer proxy object, so clients must not call
wl_pointer_destroy() after using this request.</div><div class=message-head><div class=row><div><h3><a id=wl_pointer.enter href=#wl_pointer.enter>wl_pointer.enter</a></h3><p class=summary>enter event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notification that this seat's pointer is focused on a certain
surface.<p>When a seat's focus enters a surface, the pointer image
is undefined and a client should respond to this event by setting
an appropriate pointer image with the set_cursor request.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the enter event<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface entered by the pointer<tr><td>surface_x<td>fixed<td><p>surface-local x coordinate<tr><td>surface_y<td>fixed<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.leave href=#wl_pointer.leave>wl_pointer.leave</a></h3><p class=summary>leave event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notification that this seat's pointer is no longer focused on
a certain surface.<p>The leave notification is sent before the enter notification
for the new focus.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the leave event<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface left by the pointer</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.motion href=#wl_pointer.motion>wl_pointer.motion</a></h3><p class=summary>pointer motion event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notification of pointer location change. The arguments
surface_x and surface_y are the location relative to the
focused surface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>surface_x<td>fixed<td><p>surface-local x coordinate<tr><td>surface_y<td>fixed<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.button href=#wl_pointer.button>wl_pointer.button</a></h3><p class=summary>pointer button event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Mouse button click and release notifications.<p>The location of the click is given by the last motion or
enter event.
The time argument is a timestamp with millisecond
granularity, with an undefined base.<p>The button is a button code as defined in the Linux kernel's
linux/input-event-codes.h header file, e.g. BTN_LEFT.<p>Any 16-bit button code value is reserved for future additions to the
kernel's event code list. All other button codes above 0xFFFF are
currently undefined but may be used in future versions of this
protocol.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the button event<tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>button<td>uint<td><p>button that produced the event<tr><td>state<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.button_state>button_state</a></b>><td><p>physical state of the button</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.axis href=#wl_pointer.axis>wl_pointer.axis</a></h3><p class=summary>axis event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Scroll and other axis notifications.<p>For scroll events (vertical and horizontal scroll axes), the
value parameter is the length of a vector along the specified
axis in a coordinate space identical to those of motion events,
representing a relative movement along the specified axis.<p>For devices that support movements non-parallel to axes multiple
axis events will be emitted.<p>When applicable, for example for touch pads, the server can
choose to emit scroll events where the motion vector is
equivalent to a motion event vector.<p>When applicable, a client can transform its content relative to the
scroll distance.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>axis<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis>axis</a></b>><td><p>axis type<tr><td>value<td>fixed<td><p>length of vector in surface-local coordinate space</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.frame href=#wl_pointer.frame>wl_pointer.frame</a></h3><p class=summary>end of a pointer event sequence</div><div><b>Event</b><br>Since Version 5</div></div></div><div class=description><p>Indicates the end of a set of events that logically belong together.
A client is expected to accumulate the data in all events within the
frame before proceeding.<p>All <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> events before a <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b> event belong
logically together. For example, in a diagonal scroll motion the
compositor will send an optional <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> event, two
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> events (horizontal and vertical) and finally a
<b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b> event. The client may use this information to
calculate a diagonal vector for scrolling.<p>When multiple <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> events occur within the same frame,
the motion vector is the combined motion of all events.
When a <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> and a <b><a href=/docs/wayland/wayland/#wl_pointer.axis_stop>wl_pointer.axis_stop</a></b> event occur within
the same frame, this indicates that axis movement in one axis has
stopped but continues in the other axis.
When multiple <b><a href=/docs/wayland/wayland/#wl_pointer.axis_stop>wl_pointer.axis_stop</a></b> events occur within the same
frame, this indicates that these axes stopped in the same instance.<p>A <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b> event is sent for every logical event group,
even if the group only contains a single <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> event.
Specifically, a client may get a sequence: motion, frame, button,
frame, axis, frame, axis_stop, frame.<p>The <b><a href=/docs/wayland/wayland/#wl_pointer.enter>wl_pointer.enter</a></b> and <b><a href=/docs/wayland/wayland/#wl_pointer.leave>wl_pointer.leave</a></b> events are logical events
generated by the compositor and not the hardware. These events are
also grouped by a <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>. When a pointer moves from one
surface to another, a compositor should group the
<b><a href=/docs/wayland/wayland/#wl_pointer.leave>wl_pointer.leave</a></b> event within the same <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>.
However, a client must not rely on <b><a href=/docs/wayland/wayland/#wl_pointer.leave>wl_pointer.leave</a></b> and
<b><a href=/docs/wayland/wayland/#wl_pointer.enter>wl_pointer.enter</a></b> being in the same <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>.
Compositor-specific policies may require the <b><a href=/docs/wayland/wayland/#wl_pointer.leave>wl_pointer.leave</a></b> and
<b><a href=/docs/wayland/wayland/#wl_pointer.enter>wl_pointer.enter</a></b> event being split across multiple <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>
groups.</div><div class=message-head><div class=row><div><h3><a id=wl_pointer.axis_source href=#wl_pointer.axis_source>wl_pointer.axis_source</a></h3><p class=summary>axis source event</div><div><b>Event</b><br>Since Version 5</div></div></div><div class=description><p>Source information for scroll and other axes.<p>This event does not occur on its own. It is sent before a
<b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b> event and carries the source information for
all events within that frame.<p>The source specifies how this event was generated. If the source is
<b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b>.finger, a <b><a href=/docs/wayland/wayland/#wl_pointer.axis_stop>wl_pointer.axis_stop</a></b> event will be
sent when the user lifts the finger off the device.<p>If the source is <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b>.wheel,
<b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b>.wheel_tilt or
<b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b>.continuous, a <b><a href=/docs/wayland/wayland/#wl_pointer.axis_stop>wl_pointer.axis_stop</a></b> event may
or may not be sent. Whether a compositor sends an axis_stop event
for these sources is hardware-specific and implementation-dependent;
clients must not rely on receiving an axis_stop event for these
scroll sources and should treat scroll sequences from these scroll
sources as unterminated by default.<p>This event is optional. If the source is unknown for a particular
axis event sequence, no event is sent.
Only one <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> event is permitted per frame.<p>The order of <b><a href=/docs/wayland/wayland/#wl_pointer.axis_discrete>wl_pointer.axis_discrete</a></b> and <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> is
not guaranteed.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>axis_source<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis_source>axis_source</a></b>><td><p>source of the axis event</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.axis_stop href=#wl_pointer.axis_stop>wl_pointer.axis_stop</a></h3><p class=summary>axis stop event</div><div><b>Event</b><br>Since Version 5</div></div></div><div class=description><p>Stop notification for scroll and other axes.<p>For some <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> types, a <b><a href=/docs/wayland/wayland/#wl_pointer.axis_stop>wl_pointer.axis_stop</a></b> event
is sent to notify a client that the axis sequence has terminated.
This enables the client to implement kinetic scrolling.
See the <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> documentation for information on when
this event may be generated.<p>Any <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> events with the same axis_source after this
event should be considered as the start of a new axis motion.<p>The timestamp is to be interpreted identical to the timestamp in the
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event. The timestamp value may be the same as a
preceding <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>axis<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis>axis</a></b>><td><p>the axis stopped with this event</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.axis_discrete href=#wl_pointer.axis_discrete>wl_pointer.axis_discrete</a></h3><p class=summary>axis click event</div><div><b>Event</b><br>Since Version 5</div></div></div><div class=description><p>Discrete step information for scroll and other axes.<p>This event carries the axis value of the <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event in
discrete steps (e.g. mouse wheel clicks).<p>This event is deprecated with <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> version 8 - this event is not
sent to clients supporting version 8 or later.<p>This event does not occur on its own, it is coupled with a
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event that represents this axis value on a
continuous scale. The protocol guarantees that each axis_discrete
event is always followed by exactly one axis event with the same
axis number within the same <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>. Note that the protocol
allows for other events to occur between the axis_discrete and
its coupled axis event, including other axis_discrete or axis
events. A <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b> must not contain more than one axis_discrete
event per axis type.<p>This event is optional; continuous scrolling devices
like two-finger scrolling on touchpads do not have discrete
steps and do not generate this event.<p>The discrete value carries the directional information. e.g. a value
of -2 is two steps towards the negative direction of this axis.<p>The axis number is identical to the axis number in the associated
axis event.<p>The order of <b><a href=/docs/wayland/wayland/#wl_pointer.axis_discrete>wl_pointer.axis_discrete</a></b> and <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> is
not guaranteed.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>axis<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis>axis</a></b>><td><p>axis type<tr><td>discrete<td>int<td><p>number of steps</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.axis_value120 href=#wl_pointer.axis_value120>wl_pointer.axis_value120</a></h3><p class=summary>axis high-resolution scroll event</div><div><b>Event</b><br>Since Version 8</div></div></div><div class=description><p>Discrete high-resolution scroll information.<p>This event carries high-resolution wheel scroll information,
with each multiple of 120 representing one logical scroll step
(a wheel detent). For example, an axis_value120 of 30 is one quarter of
a logical scroll step in the positive direction, a value120 of
-240 are two logical scroll steps in the negative direction within the
same hardware event.
Clients that rely on discrete scrolling should accumulate the
value120 to multiples of 120 before processing the event.<p>The value120 must not be zero.<p>This event replaces the <b><a href=/docs/wayland/wayland/#wl_pointer.axis_discrete>wl_pointer.axis_discrete</a></b> event in clients
supporting <b><a href=/docs/wayland/wayland/#wl_pointer>wl_pointer</a></b> version 8 or later.<p>Where a <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> event occurs in the same
<b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>, the axis source applies to this event.<p>The order of <b><a href=/docs/wayland/wayland/#wl_pointer.axis_value120>wl_pointer.axis_value120</a></b> and <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> is
not guaranteed.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>axis<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis>axis</a></b>><td><p>axis type<tr><td>value120<td>int<td><p>scroll distance as fraction of 120</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.axis_relative_direction href=#wl_pointer.axis_relative_direction>wl_pointer.axis_relative_direction</a></h3><p class=summary>axis relative physical direction event</div><div><b>Event</b><br>Since Version 9</div></div></div><div class=description><p>Relative directional information of the entity causing the axis
motion.<p>For a <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event, the <b><a href=/docs/wayland/wayland/#wl_pointer.axis_relative_direction>wl_pointer.axis_relative_direction</a></b>
event specifies the movement direction of the entity causing the
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event. For example:
- if a user's fingers on a touchpad move down and this
causes a <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> vertical_scroll down event, the physical
direction is 'identical'
- if a user's fingers on a touchpad move down and this causes a
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> vertical_scroll up scroll up event ('natural
scrolling'), the physical direction is 'inverted'.<p>A client may use this information to adjust scroll motion of
components. Specifically, enabling natural scrolling causes the
content to change direction compared to traditional scrolling.
Some widgets like volume control sliders should usually match the
physical direction regardless of whether natural scrolling is
active. This event enables clients to match the scroll direction of
a widget to the physical direction.<p>This event does not occur on its own, it is coupled with a
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event that represents this axis value.
The protocol guarantees that each axis_relative_direction event is
always followed by exactly one axis event with the same
axis number within the same <b><a href=/docs/wayland/wayland/#wl_pointer.frame>wl_pointer.frame</a></b>. Note that the protocol
allows for other events to occur between the axis_relative_direction
and its coupled axis event.<p>The axis number is identical to the axis number in the associated
axis event.<p>The order of <b><a href=/docs/wayland/wayland/#wl_pointer.axis_relative_direction>wl_pointer.axis_relative_direction</a></b>,
<b><a href=/docs/wayland/wayland/#wl_pointer.axis_discrete>wl_pointer.axis_discrete</a></b> and <b><a href=/docs/wayland/wayland/#wl_pointer.axis_source>wl_pointer.axis_source</a></b> is not
guaranteed.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>axis<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis>axis</a></b>><td><p>axis type<tr><td>direction<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_pointer.enums.axis_relative_direction>axis_relative_direction</a></b>><td><p>physical direction relative to axis motion</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.enums.error href=#wl_pointer.enums.error>wl_pointer.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>role<td>0<td>1<td><p>given wl_surface has another role</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.enums.button_state href=#wl_pointer.enums.button_state>wl_pointer.button_state</a></h3><p class=summary>physical button state</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>Describes the physical state of a button that produced the button
event.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>released<td>0<td>1<td><p>the button is not pressed<tr><td>pressed<td>1<td>1<td><p>the button is pressed</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.enums.axis href=#wl_pointer.enums.axis>wl_pointer.axis</a></h3><p class=summary>axis types</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>Describes the axis types of scroll events.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>vertical_scroll<td>0<td>1<td><p>vertical axis<tr><td>horizontal_scroll<td>1<td>1<td><p>horizontal axis</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.enums.axis_source href=#wl_pointer.enums.axis_source>wl_pointer.axis_source</a></h3><p class=summary>axis source types</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>Describes the source types for axis events. This indicates to the
client how an axis event was physically generated; a client may
adjust the user interface accordingly. For example, scroll events
from a "finger" source may be in a smooth coordinate space with
kinetic scrolling whereas a "wheel" source may be in discrete steps
of a number of lines.<p>The "continuous" axis source is a device generating events in a
continuous coordinate space, but using something other than a
finger. One example for this source is button-based scrolling where
the vertical motion of a device is converted to scroll events while
a button is held down.<p>The "wheel tilt" axis source indicates that the actual device is a
wheel but the scroll event is not caused by a rotation but a
(usually sideways) tilt of the wheel.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>wheel<td>0<td>1<td><p>a physical wheel rotation<tr><td>finger<td>1<td>1<td><p>finger on a touch surface<tr><td>continuous<td>2<td>1<td><p>continuous coordinate space<tr><td>wheel_tilt<td>3<td>6<td><p>a physical wheel tilt</table><div class=message-head><div class=row><div><h3><a id=wl_pointer.enums.axis_relative_direction href=#wl_pointer.enums.axis_relative_direction>wl_pointer.axis_relative_direction</a></h3><p class=summary>axis relative direction</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>This specifies the direction of the physical motion that caused a
<b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> event, relative to the <b><a href=/docs/wayland/wayland/#wl_pointer.axis>wl_pointer.axis</a></b> direction.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>identical<td>0<td>1<td><p>physical motion matches axis direction<tr><td>inverted<td>1<td>1<td><p>physical motion is the inverse of the axis direction</table><div class=interface-head><div class=row><div><h2><a id=wl_keyboard href=#wl_keyboard>wl_keyboard</a></h2><p class=summary>keyboard input device</div><div><b>Interface</b><br>Version 10</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> interface represents one or more keyboards
associated with a seat.<p>Each <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> has the following logical state:<p>- an active surface (possibly null),
- the keys currently logically down,
- the active modifiers,
- the active group.<p>By default, the active surface is null, the keys currently logically down
are empty, the active modifiers and the active group are 0.</div><div class=message-head><div class=row><div><h3><a id=wl_keyboard.release href=#wl_keyboard.release>wl_keyboard.release</a></h3><p class=summary>release the keyboard object</div><div><b>Destructor
Request</b><br>Since Version 3</div></div></div><div class=description><p></div><div class=message-head><div class=row><div><h3><a id=wl_keyboard.keymap href=#wl_keyboard.keymap>wl_keyboard.keymap</a></h3><p class=summary>keyboard mapping</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event provides a file descriptor to the client which can be
memory-mapped in read-only mode to provide a keyboard mapping
description.<p>From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
the recipient, as MAP_SHARED may fail.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>format<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_keyboard.enums.keymap_format>keymap_format</a></b>><td><p>keymap format<tr><td>fd<td>fd<td><p>keymap file descriptor<tr><td>size<td>uint<td><p>keymap size, in bytes</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.enter href=#wl_keyboard.enter>wl_keyboard.enter</a></h3><p class=summary>enter event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notification that this seat's keyboard focus is on a certain
surface.<p>The compositor must send the <b><a href=/docs/wayland/wayland/#wl_keyboard.modifiers>wl_keyboard.modifiers</a></b> event after this
event.<p>In the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> logical state, this event sets the active surface to
the surface argument and the keys currently logically down to the keys
in the keys argument. The compositor must not send this event if the
<b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> already had an active surface immediately before this event.<p>Clients should not use the list of pressed keys to emulate key-press
events. The order of keys in the list is unspecified.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the enter event<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface gaining keyboard focus<tr><td>keys<td>array<td><p>the keys currently logically down</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.leave href=#wl_keyboard.leave>wl_keyboard.leave</a></h3><p class=summary>leave event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notification that this seat's keyboard focus is no longer on
a certain surface.<p>The leave notification is sent before the enter notification
for the new focus.<p>In the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> logical state, this event resets all values to their
defaults. The compositor must not send this event if the active surface
of the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> was not equal to the surface argument immediately
before this event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the leave event<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface that lost keyboard focus</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.key href=#wl_keyboard.key>wl_keyboard.key</a></h3><p class=summary>key event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A key was pressed or released.
The time argument is a timestamp with millisecond
granularity, with an undefined base.<p>The key is a platform-specific key code that can be interpreted
by feeding it to the keyboard mapping (see the keymap event).<p>If this event produces a change in modifiers, then the resulting
<b><a href=/docs/wayland/wayland/#wl_keyboard.modifiers>wl_keyboard.modifiers</a></b> event must be sent after this event.<p>In the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> logical state, this event adds the key to the keys
currently logically down (if the state argument is pressed) or removes
the key from the keys currently logically down (if the state argument is
released). The compositor must not send this event if the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b>
did not have an active surface immediately before this event. The
compositor must not send this event if state is pressed (resp. released)
and the key was already logically down (resp. was not logically down)
immediately before this event.<p>Since version 10, compositors may send key events with the "repeated"
key state when a <b><a href=/docs/wayland/wayland/#wl_keyboard.repeat_info>wl_keyboard.repeat_info</a></b> event with a rate argument of
0 has been received. This allows the compositor to take over the
responsibility of key repetition.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the key event<tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>key<td>uint<td><p>key that produced the event<tr><td>state<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_keyboard.enums.key_state>key_state</a></b>><td><p>physical state of the key</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.modifiers href=#wl_keyboard.modifiers>wl_keyboard.modifiers</a></h3><p class=summary>modifier and group state</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Notifies clients that the modifier and/or group state has
changed, and it should update its local state.<p>The compositor may send this event without a surface of the client
having keyboard focus, for example to tie modifier information to
pointer focus instead. If a modifier event with pressed modifiers is sent
without a prior enter event, the client can assume the modifier state is
valid until it receives the next <b><a href=/docs/wayland/wayland/#wl_keyboard.modifiers>wl_keyboard.modifiers</a></b> event. In order to
reset the modifier state again, the compositor can send a
<b><a href=/docs/wayland/wayland/#wl_keyboard.modifiers>wl_keyboard.modifiers</a></b> event with no pressed modifiers.<p>In the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> logical state, this event updates the modifiers and
group.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the modifiers event<tr><td>mods_depressed<td>uint<td><p>depressed modifiers<tr><td>mods_latched<td>uint<td><p>latched modifiers<tr><td>mods_locked<td>uint<td><p>locked modifiers<tr><td>group<td>uint<td><p>keyboard layout</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.repeat_info href=#wl_keyboard.repeat_info>wl_keyboard.repeat_info</a></h3><p class=summary>repeat rate and delay</div><div><b>Event</b><br>Since Version 4</div></div></div><div class=description><p>Informs the client about the keyboard's repeat rate and delay.<p>This event is sent as soon as the <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b> object has been created,
and is guaranteed to be received by the client before any key press
event.<p>Negative values for either rate or delay are illegal. A rate of zero
will disable any repeating (regardless of the value of delay).<p>This event can be sent later on as well with a new value if necessary,
so clients should continue listening for the event past the creation
of <b><a href=/docs/wayland/wayland/#wl_keyboard>wl_keyboard</a></b>.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>rate<td>int<td><p>the rate of repeating keys in characters per second<tr><td>delay<td>int<td><p>delay in milliseconds since key down until repeating starts</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.enums.keymap_format href=#wl_keyboard.enums.keymap_format>wl_keyboard.keymap_format</a></h3><p class=summary>keyboard mapping format</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>This specifies the format of the keymap provided to the
client with the <b><a href=/docs/wayland/wayland/#wl_keyboard.keymap>wl_keyboard.keymap</a></b> event.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>no_keymap<td>0<td>1<td><p>no keymap; client must understand how to interpret the raw keycode<tr><td>xkb_v1<td>1<td>1<td><p>libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode</table><div class=message-head><div class=row><div><h3><a id=wl_keyboard.enums.key_state href=#wl_keyboard.enums.key_state>wl_keyboard.key_state</a></h3><p class=summary>physical key state</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>Describes the physical state of a key that produced the key event.<p>Since version 10, the key can be in a "repeated" pseudo-state which
means the same as "pressed", but is used to signal repetition in the
key event.<p>The key may only enter the repeated state after entering the pressed
state and before entering the released state. This event may be
generated multiple times while the key is down.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>released<td>0<td>1<td><p>key is not pressed<tr><td>pressed<td>1<td>1<td><p>key is pressed<tr><td>repeated<td>2<td>10<td><p>key was repeated</table><div class=interface-head><div class=row><div><h2><a id=wl_touch href=#wl_touch>wl_touch</a></h2><p class=summary>touchscreen input device</div><div><b>Interface</b><br>Version 10</div></div></div><div class=description><p>The <b><a href=/docs/wayland/wayland/#wl_touch>wl_touch</a></b> interface represents a touchscreen
associated with a seat.<p>Touch interactions can consist of one or more contacts.
For each contact, a series of events is generated, starting
with a down event, followed by zero or more motion events,
and ending with an up event. Events relating to the same
contact point can be identified by the ID of the sequence.</div><div class=message-head><div class=row><div><h3><a id=wl_touch.release href=#wl_touch.release>wl_touch.release</a></h3><p class=summary>release the touch object</div><div><b>Destructor
Request</b><br>Since Version 3</div></div></div><div class=description><p></div><div class=message-head><div class=row><div><h3><a id=wl_touch.down href=#wl_touch.down>wl_touch.down</a></h3><p class=summary>touch down event and beginning of a touch sequence</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A new touch point has appeared on the surface. This touch point is
assigned a unique ID. Future events from this touch point reference
this ID. The ID ceases to be valid after a touch up event and may be
reused in the future.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the touch down event<tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>surface touched<tr><td>id<td>int<td><p>the unique ID of this touch point<tr><td>x<td>fixed<td><p>surface-local x coordinate<tr><td>y<td>fixed<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_touch.up href=#wl_touch.up>wl_touch.up</a></h3><p class=summary>end of a touch event sequence</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The touch point has disappeared. No further events will be sent for
this touch point and the touch point's ID is released and may be
reused in a future touch down event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial number of the touch up event<tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>id<td>int<td><p>the unique ID of this touch point</table><div class=message-head><div class=row><div><h3><a id=wl_touch.motion href=#wl_touch.motion>wl_touch.motion</a></h3><p class=summary>update of touch point coordinates</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>A touch point has changed coordinates.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>time<td>uint<td><p>timestamp with millisecond granularity<tr><td>id<td>int<td><p>the unique ID of this touch point<tr><td>x<td>fixed<td><p>surface-local x coordinate<tr><td>y<td>fixed<td><p>surface-local y coordinate</table><div class=message-head><div class=row><div><h3><a id=wl_touch.frame href=#wl_touch.frame>wl_touch.frame</a></h3><p class=summary>end of touch frame event</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Indicates the end of a set of events that logically belong together.
A client is expected to accumulate the data in all events within the
frame before proceeding.<p>A <b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b> terminates at least one event but otherwise no
guarantee is provided about the set of events within a frame. A client
must assume that any state not updated in a frame is unchanged from the
previously known state.</div><div class=message-head><div class=row><div><h3><a id=wl_touch.cancel href=#wl_touch.cancel>wl_touch.cancel</a></h3><p class=summary>touch session cancelled</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>Sent if the compositor decides the touch stream is a global
gesture. No further events are sent to the clients from that
particular gesture. Touch cancellation applies to all touch points
currently active on this client's surface. The client is
responsible for finalizing the touch points, future touch points on
this surface may reuse the touch point ID.<p>No frame event is required after the cancel event.</div><div class=message-head><div class=row><div><h3><a id=wl_touch.shape href=#wl_touch.shape>wl_touch.shape</a></h3><p class=summary>update shape of touch point</div><div><b>Event</b><br>Since Version 6</div></div></div><div class=description><p>Sent when a touchpoint has changed its shape.<p>This event does not occur on its own. It is sent before a
<b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b> event and carries the new shape information for
any previously reported, or new touch points of that frame.<p>Other events describing the touch point such as <b><a href=/docs/wayland/wayland/#wl_touch.down>wl_touch.down</a></b>,
<b><a href=/docs/wayland/wayland/#wl_touch.motion>wl_touch.motion</a></b> or <b><a href=/docs/wayland/wayland/#wl_touch.orientation>wl_touch.orientation</a></b> may be sent within the
same <b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b>. A client should treat these events as a single
logical touch point update. The order of <b><a href=/docs/wayland/wayland/#wl_touch.shape>wl_touch.shape</a></b>,
<b><a href=/docs/wayland/wayland/#wl_touch.orientation>wl_touch.orientation</a></b> and <b><a href=/docs/wayland/wayland/#wl_touch.motion>wl_touch.motion</a></b> is not guaranteed.
A <b><a href=/docs/wayland/wayland/#wl_touch.down>wl_touch.down</a></b> event is guaranteed to occur before the first
<b><a href=/docs/wayland/wayland/#wl_touch.shape>wl_touch.shape</a></b> event for this touch ID but both events may occur within
the same <b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b>.<p>A touchpoint shape is approximated by an ellipse through the major and
minor axis length. The major axis length describes the longer diameter
of the ellipse, while the minor axis length describes the shorter
diameter. Major and minor are orthogonal and both are specified in
surface-local coordinates. The center of the ellipse is always at the
touchpoint location as reported by <b><a href=/docs/wayland/wayland/#wl_touch.down>wl_touch.down</a></b> or <b><a href=/docs/wayland/wayland/#></a></b>.<p>This event is only sent by the compositor if the touch device supports
shape reports. The client has to make reasonable assumptions about the
shape if it did not receive this event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>int<td><p>the unique ID of this touch point<tr><td>major<td>fixed<td><p>length of the major axis in surface-local coordinates<tr><td>minor<td>fixed<td><p>length of the minor axis in surface-local coordinates</table><div class=message-head><div class=row><div><h3><a id=wl_touch.orientation href=#wl_touch.orientation>wl_touch.orientation</a></h3><p class=summary>update orientation of touch point</div><div><b>Event</b><br>Since Version 6</div></div></div><div class=description><p>Sent when a touchpoint has changed its orientation.<p>This event does not occur on its own. It is sent before a
<b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b> event and carries the new shape information for
any previously reported, or new touch points of that frame.<p>Other events describing the touch point such as <b><a href=/docs/wayland/wayland/#wl_touch.down>wl_touch.down</a></b>,
<b><a href=/docs/wayland/wayland/#wl_touch.motion>wl_touch.motion</a></b> or <b><a href=/docs/wayland/wayland/#wl_touch.shape>wl_touch.shape</a></b> may be sent within the
same <b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b>. A client should treat these events as a single
logical touch point update. The order of <b><a href=/docs/wayland/wayland/#wl_touch.shape>wl_touch.shape</a></b>,
<b><a href=/docs/wayland/wayland/#wl_touch.orientation>wl_touch.orientation</a></b> and <b><a href=/docs/wayland/wayland/#wl_touch.motion>wl_touch.motion</a></b> is not guaranteed.
A <b><a href=/docs/wayland/wayland/#wl_touch.down>wl_touch.down</a></b> event is guaranteed to occur before the first
<b><a href=/docs/wayland/wayland/#wl_touch.orientation>wl_touch.orientation</a></b> event for this touch ID but both events may occur
within the same <b><a href=/docs/wayland/wayland/#wl_touch.frame>wl_touch.frame</a></b>.<p>The orientation describes the clockwise angle of a touchpoint's major
axis to the positive surface y-axis and is normalized to the -180 to
+180 degree range. The granularity of orientation depends on the touch
device, some devices only support binary rotation values between 0 and
90 degrees.<p>This event is only sent by the compositor if the touch device supports
orientation reports.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>int<td><p>the unique ID of this touch point<tr><td>orientation<td>fixed<td><p>angle between major axis and positive surface y-axis in degrees</table><div class=interface-head><div class=row><div><h2><a id=wl_output href=#wl_output>wl_output</a></h2><p class=summary>compositor output region</div><div><b>Interface</b><br>Version 4</div></div></div><div class=description><p>An output describes part of the compositor geometry. The
compositor works in the 'compositor coordinate system' and an
output corresponds to a rectangular area in that space that is
actually visible. This typically corresponds to a monitor that
displays part of the compositor space. This object is published
as global during start up, or when a monitor is hotplugged.</div><div class=message-head><div class=row><div><h3><a id=wl_output.release href=#wl_output.release>wl_output.release</a></h3><p class=summary>release the output object</div><div><b>Destructor
Request</b><br>Since Version 3</div></div></div><div class=description><p>Using this request a client can tell the server that it is not going to
use the output object anymore.</div><div class=message-head><div class=row><div><h3><a id=wl_output.geometry href=#wl_output.geometry>wl_output.geometry</a></h3><p class=summary>properties of the output</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The geometry event describes geometric properties of the output.
The event is sent when binding to the output object and whenever
any of the properties change.<p>The physical size can be set to zero if it doesn't make sense for this
output (e.g. for projectors or virtual outputs).<p>The geometry event will be followed by a done event (starting from
version 2).<p>Clients should use <b><a href=/docs/wayland/wayland/#wl_surface.preferred_buffer_transform>wl_surface.preferred_buffer_transform</a></b> instead of the
transform advertised by this event to find the preferred buffer
transform to use for a surface.<p>Note: <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> only advertises partial information about the output
position and identification. Some compositors, for instance those not
implementing a desktop-style output layout or those exposing virtual
outputs, might fake this information. Instead of using x and y, clients
should use xdg_output.logical_position. Instead of using make and model,
clients should use name and description.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>x position within the global compositor space<tr><td>y<td>int<td><p>y position within the global compositor space<tr><td>physical_width<td>int<td><p>width in millimeters of the output<tr><td>physical_height<td>int<td><p>height in millimeters of the output<tr><td>subpixel<td>int&lt;<b><a href=/docs/wayland/wayland/#wl_output.enums.subpixel>subpixel</a></b>><td><p>subpixel orientation of the output<tr><td>make<td>string<td><p>textual description of the manufacturer<tr><td>model<td>string<td><p>textual description of the model<tr><td>transform<td>int&lt;<b><a href=/docs/wayland/wayland/#wl_output.enums.transform>transform</a></b>><td><p>additional transformation applied to buffer contents during presentation</table><div class=message-head><div class=row><div><h3><a id=wl_output.mode href=#wl_output.mode>wl_output.mode</a></h3><p class=summary>advertise available modes for the output</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The mode event describes an available mode for the output.<p>The event is sent when binding to the output object and there
will always be one mode, the current mode. The event is sent
again if an output changes mode, for the mode that is now
current. In other words, the current mode is always the last
mode that was received with the current flag set.<p>Non-current modes are deprecated. A compositor can decide to only
advertise the current mode and never send other modes. Clients
should not rely on non-current modes.<p>The size of a mode is given in physical hardware units of
the output device. This is not necessarily the same as
the output size in the global compositor space. For instance,
the output may be scaled, as described in <b><a href=/docs/wayland/wayland/#wl_output.scale>wl_output.scale</a></b>,
or transformed, as described in <b><a href=/docs/wayland/wayland/#wl_output.enums.transform>wl_output.enums.transform</a></b>. Clients
willing to retrieve the output size in the global compositor
space should use xdg_output.logical_size instead.<p>The vertical refresh rate can be set to zero if it doesn't make
sense for this output (e.g. for virtual outputs).<p>The mode event will be followed by a done event (starting from
version 2).<p>Clients should not use the refresh rate to schedule frames. Instead,
they should use the <b><a href=/docs/wayland/wayland/#wl_surface.frame>wl_surface.frame</a></b> event or the presentation-time
protocol.<p>Note: this information is not always meaningful for all outputs. Some
compositors, such as those exposing virtual outputs, might fake the
refresh rate or the size.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>flags<td>uint&lt;<b><a href=/docs/wayland/wayland/#wl_output.enums.mode>mode</a></b>><td><p>bitfield of mode flags<tr><td>width<td>int<td><p>width of the mode in hardware units<tr><td>height<td>int<td><p>height of the mode in hardware units<tr><td>refresh<td>int<td><p>vertical refresh rate in mHz</table><div class=message-head><div class=row><div><h3><a id=wl_output.done href=#wl_output.done>wl_output.done</a></h3><p class=summary>sent all information about output</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>This event is sent after all other properties have been
sent after binding to the output object and after any
other property changes done after that. This allows
changes to the output properties to be seen as
atomic, even if they happen via multiple events.</div><div class=message-head><div class=row><div><h3><a id=wl_output.scale href=#wl_output.scale>wl_output.scale</a></h3><p class=summary>output scaling properties</div><div><b>Event</b><br>Since Version 2</div></div></div><div class=description><p>This event contains scaling geometry information
that is not in the geometry event. It may be sent after
binding the output object or if the output scale changes
later. The compositor will emit a non-zero, positive
value for scale. If it is not sent, the client should
assume a scale of 1.<p>A scale larger than 1 means that the compositor will
automatically scale surface buffers by this amount
when rendering. This is used for very high resolution
displays where applications rendering at the native
resolution would be too small to be legible.<p>Clients should use <b><a href=/docs/wayland/wayland/#wl_surface.preferred_buffer_scale>wl_surface.preferred_buffer_scale</a></b>
instead of this event to find the preferred buffer
scale to use for a surface.<p>The scale event will be followed by a done event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>factor<td>int<td><p>scaling factor of output</table><div class=message-head><div class=row><div><h3><a id=wl_output.name href=#wl_output.name>wl_output.name</a></h3><p class=summary>name of this output</div><div><b>Event</b><br>Since Version 4</div></div></div><div class=description><p>Many compositors will assign user-friendly names to their outputs, show
them to the user, allow the user to refer to an output, etc. The client
may wish to know this name as well to offer the user similar behaviors.<p>The name is a UTF-8 string with no convention defined for its contents.
Each name is unique among all <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> globals. The name is only
guaranteed to be unique for the compositor instance.<p>The same output name is used for all clients for a given <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b>
global. Thus, the name can be shared across processes to refer to a
specific <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> global.<p>The name is not guaranteed to be persistent across sessions, thus cannot
be used to reliably identify an output in e.g. configuration files.<p>Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
not assume that the name is a reflection of an underlying DRM connector,
X11 connection, etc.<p>The name event is sent after binding the output object. This event is
only sent once per output object, and the name does not change over the
lifetime of the <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> global.<p>Compositors may re-use the same output name if the <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> global is
destroyed and re-created later. Compositors should avoid re-using the
same name if possible.<p>The name event will be followed by a done event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>name<td>string<td><p>output name</table><div class=message-head><div class=row><div><h3><a id=wl_output.description href=#wl_output.description>wl_output.description</a></h3><p class=summary>human-readable description of this output</div><div><b>Event</b><br>Since Version 4</div></div></div><div class=description><p>Many compositors can produce human-readable descriptions of their
outputs. The client may wish to know this description as well, e.g. for
output selection purposes.<p>The description is a UTF-8 string with no convention defined for its
contents. The description is not guaranteed to be unique among all
<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> globals. Examples might include 'Foocorp 11" Display' or
'Virtual X11 output via :1'.<p>The description event is sent after binding the output object and
whenever the description changes. The description is optional, and may
not be sent at all.<p>The description event will be followed by a done event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>description<td>string<td><p>output description</table><div class=message-head><div class=row><div><h3><a id=wl_output.enums.subpixel href=#wl_output.enums.subpixel>wl_output.subpixel</a></h3><p class=summary>subpixel geometry information</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>This enumeration describes how the physical
pixels on an output are laid out.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>unknown<td>0<td>1<td><p>unknown geometry<tr><td>none<td>1<td>1<td><p>no geometry<tr><td>horizontal_rgb<td>2<td>1<td><p>horizontal RGB<tr><td>horizontal_bgr<td>3<td>1<td><p>horizontal BGR<tr><td>vertical_rgb<td>4<td>1<td><p>vertical RGB<tr><td>vertical_bgr<td>5<td>1<td><p>vertical BGR</table><div class=message-head><div class=row><div><h3><a id=wl_output.enums.transform href=#wl_output.enums.transform>wl_output.transform</a></h3><p class=summary>transformation applied to buffer contents</div><div><b>Enum</b><br>Since Version 1</div></div></div><div class=description><p>This describes transformations that clients and compositors apply to
buffer contents.<p>The flipped values correspond to an initial flip around a
vertical axis followed by rotation.<p>The purpose is mainly to allow clients to render accordingly and
tell the compositor, so that for fullscreen surfaces, the
compositor will still be able to scan out directly from client
surfaces.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>normal<td>0<td>1<td><p>no transform<tr><td>90<td>1<td>1<td><p>90 degrees counter-clockwise<tr><td>180<td>2<td>1<td><p>180 degrees counter-clockwise<tr><td>270<td>3<td>1<td><p>270 degrees counter-clockwise<tr><td>flipped<td>4<td>1<td><p>180 degree flip around a vertical axis<tr><td>flipped_90<td>5<td>1<td><p>flip and rotate 90 degrees counter-clockwise<tr><td>flipped_180<td>6<td>1<td><p>flip and rotate 180 degrees counter-clockwise<tr><td>flipped_270<td>7<td>1<td><p>flip and rotate 270 degrees counter-clockwise</table><div class=message-head><div class=row><div><h3><a id=wl_output.enums.mode href=#wl_output.enums.mode>wl_output.mode</a></h3><p class=summary>mode information</div><div><b>Bitfield
Enum</b><br>Since Version 1</div></div></div><div class=description><p>These flags describe properties of an output mode.
They are used in the flags bitfield of the mode event.</div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>current<td>0x1<td>1<td><p>indicates this is the current mode<tr><td>preferred<td>0x2<td>1<td><p>indicates this is the preferred mode</table><div class=interface-head><div class=row><div><h2><a id=wl_region href=#wl_region>wl_region</a></h2><p class=summary>region interface</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>A region object describes an area.<p>Region objects are used to describe the opaque and input
regions of a surface.</div><div class=message-head><div class=row><div><h3><a id=wl_region.destroy href=#wl_region.destroy>wl_region.destroy</a></h3><p class=summary>destroy region</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Destroy the region. This will invalidate the object ID.</div><div class=message-head><div class=row><div><h3><a id=wl_region.add href=#wl_region.add>wl_region.add</a></h3><p class=summary>add rectangle to region</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Add the specified rectangle to the region.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>region-local x coordinate<tr><td>y<td>int<td><p>region-local y coordinate<tr><td>width<td>int<td><p>rectangle width<tr><td>height<td>int<td><p>rectangle height</table><div class=message-head><div class=row><div><h3><a id=wl_region.subtract href=#wl_region.subtract>wl_region.subtract</a></h3><p class=summary>subtract rectangle from region</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Subtract the specified rectangle from the region.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>region-local x coordinate<tr><td>y<td>int<td><p>region-local y coordinate<tr><td>width<td>int<td><p>rectangle width<tr><td>height<td>int<td><p>rectangle height</table><div class=interface-head><div class=row><div><h2><a id=wl_subcompositor href=#wl_subcompositor>wl_subcompositor</a></h2><p class=summary>sub-surface compositing</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>The global interface exposing sub-surface compositing capabilities.
A <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>, that has sub-surfaces associated, is called the
parent surface. Sub-surfaces can be arbitrarily nested and create
a tree of sub-surfaces.<p>The root surface in a tree of sub-surfaces is the main
surface. The main surface cannot be a sub-surface, because
sub-surfaces must always have a parent.<p>A main surface with its sub-surfaces forms a (compound) window.
For window management purposes, this set of <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> objects is
to be considered as a single window, and it should also behave as
such.<p>The aim of sub-surfaces is to offload some of the compositing work
within a window from clients to the compositor. A prime example is
a video player with decorations and video in separate <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>
objects. This should allow the compositor to pass YUV video buffer
processing to dedicated overlay hardware when possible.</div><div class=message-head><div class=row><div><h3><a id=wl_subcompositor.destroy href=#wl_subcompositor.destroy>wl_subcompositor.destroy</a></h3><p class=summary>unbind from the subcompositor interface</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>Informs the server that the client will not be using this
protocol object anymore. This does not affect any other
objects, <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> objects included.</div><div class=message-head><div class=row><div><h3><a id=wl_subcompositor.get_subsurface href=#wl_subcompositor.get_subsurface>wl_subcompositor.get_subsurface</a></h3><p class=summary>give a surface the role sub-surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Create a sub-surface interface for the given surface, and
associate it with the given parent surface. This turns a
plain <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> into a sub-surface.<p>The to-be sub-surface must not already have another role, and it
must not have an existing <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> object. Otherwise the
bad_surface protocol error is raised.<p>Adding sub-surfaces to a parent is a double-buffered operation on the
parent (see <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b>). The effect of adding a sub-surface
becomes visible on the next time the state of the parent surface is
applied.<p>The parent surface must not be one of the child surface's descendants,
and the parent must be different from the child surface, otherwise the
bad_parent protocol error is raised.<p>This request modifies the behaviour of <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> request on
the sub-surface, see the documentation on <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> interface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b>><td><p>the new sub-surface object ID<tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>the surface to be turned into a sub-surface<tr><td>parent<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>the parent surface</table><div class=message-head><div class=row><div><h3><a id=wl_subcompositor.enums.error href=#wl_subcompositor.enums.error>wl_subcompositor.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>bad_surface<td>0<td>1<td><p>the to-be sub-surface is invalid<tr><td>bad_parent<td>1<td>1<td><p>the to-be sub-surface parent is invalid</table><div class=interface-head><div class=row><div><h2><a id=wl_subsurface href=#wl_subsurface>wl_subsurface</a></h2><p class=summary>sub-surface interface to a wl_surface</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>An additional interface to a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> object, which has been
made a sub-surface. A sub-surface has one parent surface. A
sub-surface's size and position are not limited to that of the parent.
Particularly, a sub-surface is not automatically clipped to its
parent's area.<p>A sub-surface becomes mapped, when a non-NULL <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> is applied
and the parent surface is mapped. The order of which one happens
first is irrelevant. A sub-surface is hidden if the parent becomes
hidden, or if a NULL <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b> is applied. These rules apply
recursively through the tree of surfaces.<p>A sub-surface can be in one of two modes. The possible modes are
synchronized and desynchronized, see methods <b><a href=/docs/wayland/wayland/#wl_subsurface.set_sync>wl_subsurface.set_sync</a></b> and
<b><a href=/docs/wayland/wayland/#wl_subsurface.set_desync>wl_subsurface.set_desync</a></b>.<p>The main surface can be thought to be always in desynchronized mode,
since it does not have a parent in the sub-surfaces sense.<p>Even if a sub-surface is in desynchronized mode, it will behave as
in synchronized mode, if its parent surface behaves as in
synchronized mode. This rule is applied recursively throughout the
tree of surfaces. This means, that one can set a sub-surface into
synchronized mode, and then assume that all its child and grand-child
sub-surfaces are synchronized, too, without explicitly setting them.<p>If a surface behaves as in synchronized mode, it is effectively
synchronized, otherwise it is effectively desynchronized.<p>A sub-surface is initially in the synchronized mode.<p>The <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> interface has requests which modify double-buffered
state of the parent surface (<b><a href=/docs/wayland/wayland/#wl_subsurface.set_position>wl_subsurface.set_position</a></b>, .place_above and
.place_below).<p>Destroying a sub-surface takes effect immediately. If you need to
synchronize the removal of a sub-surface to the parent surface update,
unmap the sub-surface first by attaching a NULL <b><a href=/docs/wayland/wayland/#wl_buffer>wl_buffer</a></b>, update parent,
and then destroy the sub-surface.<p>If the parent <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> object is destroyed, the sub-surface is
unmapped.<p>A sub-surface never has the keyboard focus of any seat.<p>The <b><a href=/docs/wayland/wayland/#wl_surface.offset>wl_surface.offset</a></b> request is ignored: clients must use set_position
instead to move the sub-surface.</div><div class=message-head><div class=row><div><h3><a id=wl_subsurface.destroy href=#wl_subsurface.destroy>wl_subsurface.destroy</a></h3><p class=summary>remove sub-surface interface</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>The sub-surface interface is removed from the <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> object
that was turned into a sub-surface with a
<b><a href=/docs/wayland/wayland/#wl_subcompositor.get_subsurface>wl_subcompositor.get_subsurface</a></b> request. The <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>'s association
to the parent is deleted. The <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> is unmapped immediately.</div><div class=message-head><div class=row><div><h3><a id=wl_subsurface.set_position href=#wl_subsurface.set_position>wl_subsurface.set_position</a></h3><p class=summary>reposition the sub-surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This sets the position of the sub-surface, relative to the parent
surface.<p>The sub-surface will be moved so that its origin (top left
corner pixel) will be at the location x, y of the parent surface
coordinate system. The coordinates are not restricted to the parent
surface area. Negative values are allowed.<p>The initial position is 0, 0.<p>Position is double-buffered state on the parent surface, see
<b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> and <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> for more information.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>x<td>int<td><p>x coordinate in the parent surface<tr><td>y<td>int<td><p>y coordinate in the parent surface</table><div class=message-head><div class=row><div><h3><a id=wl_subsurface.place_above href=#wl_subsurface.place_above>wl_subsurface.place_above</a></h3><p class=summary>restack the sub-surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This sub-surface is taken from the stack, and put back just
above the reference surface, changing the z-order of the sub-surfaces.
The reference surface must be one of the sibling surfaces, or the
parent surface. Using any other surface, including this sub-surface,
will cause a protocol error.<p>A new sub-surface is initially added as the top-most in the stack
of its siblings and parent.<p>Z-order is double-buffered state on the parent surface, see
<b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> and <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> for more information.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>sibling<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>the reference surface</table><div class=message-head><div class=row><div><h3><a id=wl_subsurface.place_below href=#wl_subsurface.place_below>wl_subsurface.place_below</a></h3><p class=summary>restack the sub-surface</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>The sub-surface is placed just below the reference surface.<p>See <b><a href=/docs/wayland/wayland/#wl_subsurface.place_above>wl_subsurface.place_above</a></b>.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>sibling<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p>the reference surface</table><div class=message-head><div class=row><div><h3><a id=wl_subsurface.set_sync href=#wl_subsurface.set_sync>wl_subsurface.set_sync</a></h3><p class=summary>set sub-surface to synchronized mode</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Change the commit behaviour of the sub-surface to synchronized
mode.<p>See <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> and <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> for more information.</div><div class=message-head><div class=row><div><h3><a id=wl_subsurface.set_desync href=#wl_subsurface.set_desync>wl_subsurface.set_desync</a></h3><p class=summary>set sub-surface to desynchronized mode</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>Change the commit behaviour of the sub-surface to desynchronized
mode.<p>See <b><a href=/docs/wayland/wayland/#wl_subsurface>wl_subsurface</a></b> and <b><a href=/docs/wayland/wayland/#wl_surface.commit>wl_surface.commit</a></b> for more information.</div><div class=message-head><div class=row><div><h3><a id=wl_subsurface.enums.error href=#wl_subsurface.enums.error>wl_subsurface.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>bad_surface<td>0<td>1<td><p>wl_surface is not a sibling or the parent</table><div class=interface-head><div class=row><div><h2><a id=wl_fixes href=#wl_fixes>wl_fixes</a></h2><p class=summary>wayland protocol fixes</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>This global fixes problems with other core-protocol interfaces that
cannot be fixed in these interfaces themselves.</div><div class=message-head><div class=row><div><h3><a id=wl_fixes.destroy href=#wl_fixes.destroy>wl_fixes.destroy</a></h3><p class=summary>destroys this object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p></div><div class=message-head><div class=row><div><h3><a id=wl_fixes.destroy_registry href=#wl_fixes.destroy_registry>wl_fixes.destroy_registry</a></h3><p class=summary>destroy a wl_registry</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request destroys a <b><a href=/docs/wayland/wayland/#wl_registry>wl_registry</a></b> object.<p>The client should no longer use the <b><a href=/docs/wayland/wayland/#wl_registry>wl_registry</a></b> after making this
request.<p>The compositor will emit a <b><a href=/docs/wayland/wayland/#wl_display.delete_id>wl_display.delete_id</a></b> event with the object ID
of the registry and will no longer emit any events on the registry. The
client should re-use the object ID once it receives the
<b><a href=/docs/wayland/wayland/#wl_display.delete_id>wl_display.delete_id</a></b> event.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>registry<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_registry>wl_registry</a></b>><td><p>the registry to destroy</table><div class=interface-head><h2>Copyright</h2></div><div class=copyright><p><br>Copyright  2008-2011 Kristian Hgsberg<br>Copyright  2010-2011 Intel Corporation<br>Copyright  2012-2013 Collabora, Ltd.<br><br>Permission is hereby granted, free of charge, to any person<br>obtaining a copy of this software and associated documentation files<br>(the "Software"), to deal in the Software without restriction,<br>including without limitation the rights to use, copy, modify, merge,<br>publish, distribute, sublicense, and/or sell copies of the Software,<br>and to permit persons to whom the Software is furnished to do so,<br>subject to the following conditions:<br><br>The above copyright notice and this permission notice (including the<br>next paragraph) shall be included in all copies or substantial<br>portions of the Software.<br><br>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,<br>EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF<br>MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND<br>NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS<br>BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN<br>ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN<br>CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.<br></div></div></main><footer><span class=line> 2021-2026 Isaac Freund,</span>
<span class=line><a href=/impressum>Impressum</a>,</span>
<span class=line>Content <a href=/CC-BY-NC-SA-4.0.txt>CC-BY-NC-SA-4.0</a>,</span>
<span class=line><a href=https://codeberg.org/ifreund/website>Source Code</a> <a href=/AGPL-3.0-only.txt>AGPL-3.0-only</a></span></footer>