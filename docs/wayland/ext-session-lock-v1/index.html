<!doctype html><html lang=en><meta name=viewport content="width=device-width,initial-scale=1"><title></title><link rel=icon href=/if.png><link rel=stylesheet href=/style.css><link rel=alternate href=/blog/feed.xml type=application/atom+xml title="Isaac Freund's Blog"><link rel=alternate href=/poetry/feed.xml type=application/atom+xml title="Isaac Freund's Poetry"><link rel=me href=https://hachyderm.io/@ifreund><header><nav><input type=checkbox id=toggle><div class=nav-bar><div class=nav-home><a href=/><svg viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="1" height="1"/><rect x="0" y="2" width="1" height="3"/><path d="M2 0h3v1H3v1h2v1H3v2H2V0z"/><rect x="4" y="4" width="1" height="1"/></svg></a></div><div class=menu><label for=toggle class=menu-button><svg class="menu-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><rect x="0" y="0" width="5" height="1"/><rect x="0" y="2" width="5" height="1"/><rect x="0" y="4" width="5" height="1"/></svg>
<svg class="close-icon" viewBox="0 0 5 5" shape-rendering="crispEdges"><line x1="0" y1="0" x2="5" y2="5"/><line x1="0" y1="5" x2="5" y2="0"/></svg></label></div></div></div><div class=nav-items><a href=/about>about</a>
<a href=/blog>blog</a>
<a href=/software>software</a>
<a href=/poetry>poetry</a>
<a href=/consulting>consulting</a></div></nav></header><main class="wayland ext-session-lock-v1"><div class=title><h1>ext-session-lock-v1</h1><p class=summary>secure session locking with arbitrary graphics</div><div class=content><div class=description><p>This protocol allows for a privileged Wayland client to lock the session
and display arbitrary graphics while the session is locked.<p>The compositor may choose to restrict this protocol to a special client
launched by the compositor itself or expose it to all privileged clients,
this is compositor policy.<p>The client is responsible for performing authentication and informing the
compositor when the session should be unlocked. If the client dies while
the session is locked the session remains locked, possibly permanently
depending on compositor policy.<p>The key words "must", "must not", "required", "shall", "shall not",
"should", "should not", "recommended", "may", and "optional" in this
document are to be interpreted as described in IETF RFC 2119.<p>Warning! The protocol described in this file is currently in the
testing phase. Backward compatible changes may be added together with
the corresponding interface version bump. Backward incompatible changes
can only be done by creating a new major version of the extension.</div><div class=interface-head><div class=row><div><h2><a id=ext_session_lock_manager_v1 href=#ext_session_lock_manager_v1>ext_session_lock_manager_v1</a></h2><p class=summary>used to lock the session</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>This interface is used to request that the session be locked.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_manager_v1.destroy href=#ext_session_lock_manager_v1.destroy>ext_session_lock_manager_v1.destroy</a></h3><p class=summary>destroy the session lock manager object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This informs the compositor that the session lock manager object will
no longer be used. Existing objects created through this interface
remain valid.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_manager_v1.lock href=#ext_session_lock_manager_v1.lock>ext_session_lock_manager_v1.lock</a></h3><p class=summary>attempt to lock the session</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>This request creates a session lock and asks the compositor to lock the
session. The compositor will send either the <b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_v1.locked>ext_session_lock_v1.locked</a></b>
or <b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_v1.finished>ext_session_lock_v1.finished</a></b> event on the created object in
response to this request.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_v1>ext_session_lock_v1</a></b>><td><p></table><div class=interface-head><div class=row><div><h2><a id=ext_session_lock_v1 href=#ext_session_lock_v1>ext_session_lock_v1</a></h2><p class=summary>manage lock state and create lock surfaces</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>In response to the creation of this object the compositor must send
either the locked or finished event.<p>The locked event indicates that the session is locked. This means
that the compositor must stop rendering and providing input to normal
clients. Instead the compositor must blank all outputs with an opaque
color such that their normal content is fully hidden.<p>The only surfaces that should be rendered while the session is locked
are the lock surfaces created through this interface and optionally,
at the compositor's discretion, special privileged surfaces such as
input methods or portions of desktop shell UIs.<p>The locked event must not be sent until a new "locked" frame (either
from a session lock surface or the compositor blanking the output) has
been presented on all outputs and no security sensitive normal/unlocked
content is possibly visible.<p>The finished event should be sent immediately on creation of this
object if the compositor decides that the locked event will not be sent.<p>The compositor may wait for the client to create and render session lock
surfaces before sending the locked event to avoid displaying intermediate
blank frames. However, it must impose a reasonable time limit if
waiting and send the locked event as soon as the hard requirements
described above can be met if the time limit expires. Clients should
immediately create lock surfaces for all outputs on creation of this
object to make this possible.<p>This behavior of the locked event is required in order to prevent
possible race conditions with clients that wish to suspend the system
or similar after locking the session. Without these semantics, clients
triggering a suspend after receiving the locked event would race with
the first "locked" frame being presented and normal/unlocked frames
might be briefly visible as the system is resumed if the suspend
operation wins the race.<p>If the client dies while the session is locked, the compositor must not
unlock the session in response. It is acceptable for the session to be
permanently locked if this happens. The compositor may choose to continue
to display the lock surfaces the client had mapped before it died or
alternatively fall back to a solid color, this is compositor policy.<p>Compositors may also allow a secure way to recover the session, the
details of this are compositor policy. Compositors may allow a new
client to create a <b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_v1>ext_session_lock_v1</a></b> object and take responsibility
for unlocking the session, they may even start a new lock client
instance automatically.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_v1.destroy href=#ext_session_lock_v1.destroy>ext_session_lock_v1.destroy</a></h3><p class=summary>destroy the session lock</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This informs the compositor that the lock object will no longer be
used. Existing objects created through this interface remain valid.<p>After this request is made, lock surfaces created through this object
should be destroyed by the client as they will no longer be used by
the compositor.<p>It is a protocol error to make this request if the locked event was
sent, the unlock_and_destroy request must be used instead.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_v1.get_lock_surface href=#ext_session_lock_v1.get_lock_surface>ext_session_lock_v1.get_lock_surface</a></h3><p class=summary>create a lock surface for a given output</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>The client is expected to create lock surfaces for all outputs
currently present and any new outputs as they are advertised. These
won't be displayed by the compositor unless the lock is successful
and the locked event is sent.<p>Providing a <b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b> which already has a role or already has a buffer
attached or committed is a protocol error, as is attaching/committing
a buffer before the first <b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_surface_v1.configure>ext_session_lock_surface_v1.configure</a></b> event.<p>Attempting to create more than one lock surface for a given output
is a duplicate_output protocol error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>id<td>new_id&lt;<b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_surface_v1>ext_session_lock_surface_v1</a></b>><td><p><tr><td>surface<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_surface>wl_surface</a></b>><td><p><tr><td>output<td>object&lt;<b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b>><td><p></table><div class=message-head><div class=row><div><h3><a id=ext_session_lock_v1.unlock_and_destroy href=#ext_session_lock_v1.unlock_and_destroy>ext_session_lock_v1.unlock_and_destroy</a></h3><p class=summary>unlock the session, destroying the object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This request indicates that the session should be unlocked, for
example because the user has entered their password and it has been
verified by the client.<p>This request also informs the compositor that the lock object will
no longer be used and should be destroyed. Existing objects created
through this interface remain valid.<p>After this request is made, lock surfaces created through this object
should be destroyed by the client as they will no longer be used by
the compositor.<p>It is a protocol error to make this request if the locked event has
not been sent. In that case, the lock object must be destroyed using
the destroy request.<p>Note that a correct client that wishes to exit directly after unlocking
the session must use the <b><a href=/docs/wayland/wayland/#wl_display.sync>wl_display.sync</a></b> request to ensure the server
receives and processes the unlock_and_destroy request. Otherwise
there is no guarantee that the server has unlocked the session due
to the asynchronous nature of the Wayland protocol. For example,
the server might terminate the client with a protocol error before
it processes the unlock_and_destroy request.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_v1.locked href=#ext_session_lock_v1.locked>ext_session_lock_v1.locked</a></h3><p class=summary>session successfully locked</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This client is now responsible for displaying graphics while the
session is locked and deciding when to unlock the session.<p>The locked event must not be sent until a new "locked" frame has been
presented on all outputs and no security sensitive normal/unlocked
content is possibly visible.<p>If this event is sent, making the destroy request is a protocol error,
the lock object must be destroyed using the unlock_and_destroy request.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_v1.finished href=#ext_session_lock_v1.finished>ext_session_lock_v1.finished</a></h3><p class=summary>the session lock object should be destroyed</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>The compositor has decided that the session lock should be destroyed
as it will no longer be used by the compositor. Exactly when this
event is sent is compositor policy, but it must never be sent more
than once for a given session lock object.<p>This might be sent because there is already another <b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_v1>ext_session_lock_v1</a></b>
object held by a client, or the compositor has decided to deny the
request to lock the session for some other reason. This might also
be sent because the compositor implements some alternative, secure
way to authenticate and unlock the session.<p>The finished event should be sent immediately on creation of this
object if the compositor decides that the locked event will not
be sent.<p>If the locked event is sent on creation of this object the finished
event may still be sent at some later time in this object's
lifetime. This is compositor policy.<p>Upon receiving this event, the client should make either the destroy
request or the unlock_and_destroy request, depending on whether or
not the locked event was received on this object.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_v1.enums.error href=#ext_session_lock_v1.enums.error>ext_session_lock_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>invalid_destroy<td>0<td>1<td><p>attempted to destroy session lock while locked<tr><td>invalid_unlock<td>1<td>1<td><p>unlock requested but locked event was never sent<tr><td>role<td>2<td>1<td><p>given wl_surface already has a role<tr><td>duplicate_output<td>3<td>1<td><p>given output already has a lock surface<tr><td>already_constructed<td>4<td>1<td><p>given wl_surface has a buffer attached or committed</table><div class=interface-head><div class=row><div><h2><a id=ext_session_lock_surface_v1 href=#ext_session_lock_surface_v1>ext_session_lock_surface_v1</a></h2><p class=summary>a surface displayed while the session is locked</div><div><b>Interface</b><br>Version 1</div></div></div><div class=description><p>The client may use lock surfaces to display a screensaver, render a
dialog to enter a password and unlock the session, or however else it
sees fit.<p>On binding this interface the compositor will immediately send the
first configure event. After making the ack_configure request in
response to this event the client should attach and commit the first
buffer. Committing the surface before acking the first configure is a
protocol error. Committing the surface with a null buffer at any time
is a protocol error.<p>The compositor is free to handle keyboard/pointer focus for lock
surfaces however it chooses. A reasonable way to do this would be to
give the first lock surface created keyboard focus and change keyboard
focus if the user clicks on other surfaces.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_surface_v1.destroy href=#ext_session_lock_surface_v1.destroy>ext_session_lock_surface_v1.destroy</a></h3><p class=summary>destroy the lock surface object</div><div><b>Destructor
Request</b><br>Since Version 1</div></div></div><div class=description><p>This informs the compositor that the lock surface object will no
longer be used.<p>It is recommended for a lock client to destroy lock surfaces if
their corresponding <b><a href=/docs/wayland/wayland/#wl_output>wl_output</a></b> global is removed.<p>If a lock surface on an active output is destroyed before the
<b><a href=/docs/wayland/ext-session-lock-v1/#ext_session_lock_v1.unlock_and_destroy>ext_session_lock_v1.unlock_and_destroy</a></b> event is sent, the compositor
must fall back to rendering a solid color.</div><div class=message-head><div class=row><div><h3><a id=ext_session_lock_surface_v1.ack_configure href=#ext_session_lock_surface_v1.ack_configure>ext_session_lock_surface_v1.ack_configure</a></h3><p class=summary>ack a configure event</div><div><b>Request</b><br>Since Version 1</div></div></div><div class=description><p>When a configure event is received, if a client commits the surface
in response to the configure event, then the client must make an
ack_configure request sometime before the commit request, passing
along the serial of the configure event.<p>If the client receives multiple configure events before it can
respond to one, it only has to ack the last configure event.<p>A client is not required to commit immediately after sending an
ack_configure request - it may even ack_configure several times
before its next surface commit.<p>A client may send multiple ack_configure requests before committing,
but only the last request sent before a commit indicates which
configure event the client really is responding to.<p>Sending an ack_configure request consumes the configure event
referenced by the given serial, as well as all older configure events
sent on this object.<p>It is a protocol error to issue multiple ack_configure requests
referencing the same configure event or to issue an ack_configure
request referencing a configure event older than the last configure
event acked for a given lock surface.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial from the configure event</table><div class=message-head><div class=row><div><h3><a id=ext_session_lock_surface_v1.configure href=#ext_session_lock_surface_v1.configure>ext_session_lock_surface_v1.configure</a></h3><p class=summary>the client should resize its surface</div><div><b>Event</b><br>Since Version 1</div></div></div><div class=description><p>This event is sent once on binding the interface and may be sent again
at the compositor's discretion, for example if output geometry changes.<p>The width and height are in surface-local coordinates and are exact
requirements. Failing to match these surface dimensions in the next
commit after acking a configure is a protocol error.</div><table class=args><thead><tr><th>Argument<th>Type<th>Description<tbody><tr><td>serial<td>uint<td><p>serial for use in ack_configure<tr><td>width<td>uint<td><p><tr><td>height<td>uint<td><p></table><div class=message-head><div class=row><div><h3><a id=ext_session_lock_surface_v1.enums.error href=#ext_session_lock_surface_v1.enums.error>ext_session_lock_surface_v1.error</a></h3><p class=summary></div><div><b>Enum</b><br>Since Version 1</div></div></div><table class=enum><thead><tr><th>Entry<th>Value<th>Since<th>Description<tbody><tr><td>commit_before_first_ack<td>0<td>1<td><p>surface committed before first ack_configure request<tr><td>null_buffer<td>1<td>1<td><p>surface committed with a null buffer<tr><td>dimensions_mismatch<td>2<td>1<td><p>failed to match ack'd width/height<tr><td>invalid_serial<td>3<td>1<td><p>serial provided in ack_configure is invalid</table><div class=interface-head><h2>Copyright</h2></div><div class=copyright><p><br>Copyright 2021 Isaac Freund<br><br>Permission is hereby granted, free of charge, to any person obtaining a<br>copy of this software and associated documentation files (the "Software"),<br>to deal in the Software without restriction, including without limitation<br>the rights to use, copy, modify, merge, publish, distribute, sublicense,<br>and/or sell copies of the Software, and to permit persons to whom the<br>Software is furnished to do so, subject to the following conditions:<br><br>The above copyright notice and this permission notice shall be included in<br>all copies or substantial portions of the Software.<br><br>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL<br>THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br>THE SOFTWARE.<br></div></div></main><footer><span class=line>Â© 2021-2026 Isaac Freund,</span>
<span class=line><a href=/impressum>Impressum</a>,</span>
<span class=line>Content <a href=/CC-BY-NC-SA-4.0.txt>CC-BY-NC-SA-4.0</a>,</span>
<span class=line><a href=https://codeberg.org/ifreund/website>Source Code</a> <a href=/AGPL-3.0-only.txt>AGPL-3.0-only</a></span></footer>